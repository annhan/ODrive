/*
 * ============================ WARNING ============================
 * ==== This is an autogenerated file.                          ====
 * ==== Any changes to this file will be lost when recompiling. ====
 * =================================================================
 *
 * This file contains base classes that correspond to the interfaces defined in
 * your interface file. The objects you publish should inherit from these
 * interfaces.
 *
 */

#pragma GCC push_options
#pragma GCC optimize ("s")



class ODriveIntf {
public:
    class CanIntf {
    public:
        class ConfigIntf {
        public:
            template<typename T> static inline auto get_baud_rate(T* obj) { return Property<const uint32_t>{&obj->baud_rate}; }
            template<typename T> static inline void get_baud_rate(T* obj, void* ptr) { new (ptr) Property<const uint32_t>{&obj->baud_rate}; }
            template<typename T> static inline auto get_protocol(T* obj) { return Property<ODriveIntf::CanIntf::Protocol>{&obj->protocol}; }
            template<typename T> static inline void get_protocol(T* obj, void* ptr) { new (ptr) Property<ODriveIntf::CanIntf::Protocol>{&obj->protocol}; }
        };
        enum Error {
            ERROR_NONE                       = 0x00000000,
            ERROR_DUPLICATE_CAN_IDS          = 0x00000001,
        };
        enum Protocol {
            PROTOCOL_SIMPLE                  = 0,
        };
        template<typename T> static inline auto get_error(T* obj) { return Property<ODriveIntf::CanIntf::Error>{&obj->error_}; }
        template<typename T> static inline void get_error(T* obj, void* ptr) { new (ptr) Property<ODriveIntf::CanIntf::Error>{&obj->error_}; }
        template<typename T> static inline auto get_config(T* obj) { return &obj->config_; }
        virtual void set_baud_rate(uint32_t baudRate) = 0;
        uint32_t set_baud_rate_in_baudRate_; // for internal use by Fibre
        template<typename T> static auto get_set_baud_rate_in_baudRate_(T* obj) { return Property<uint32_t>{&obj->set_baud_rate_in_baudRate_}; }
        template<typename T> static void get_set_baud_rate_in_baudRate_(T* obj, void* ptr) { new (ptr) Property<uint32_t>{&obj->set_baud_rate_in_baudRate_}; }
    };
    class EndpointIntf {
    public:
        template<typename T> static inline auto get_endpoint(T* obj) { return Property<endpoint_ref_t>{&obj->endpoint}; }
        template<typename T> static inline void get_endpoint(T* obj, void* ptr) { new (ptr) Property<endpoint_ref_t>{&obj->endpoint}; }
        template<typename T> static inline auto get_min(T* obj) { return Property<float>{&obj->min}; }
        template<typename T> static inline void get_min(T* obj, void* ptr) { new (ptr) Property<float>{&obj->min}; }
        template<typename T> static inline auto get_max(T* obj) { return Property<float>{&obj->max}; }
        template<typename T> static inline void get_max(T* obj, void* ptr) { new (ptr) Property<float>{&obj->max}; }
    };
    class AxisIntf {
    public:
        class LockinConfigIntf {
        public:
            template<typename T> static inline auto get_current(T* obj) { return Property<float>{&obj->current}; }
            template<typename T> static inline void get_current(T* obj, void* ptr) { new (ptr) Property<float>{&obj->current}; }
            template<typename T> static inline auto get_ramp_time(T* obj) { return Property<float>{&obj->ramp_time}; }
            template<typename T> static inline void get_ramp_time(T* obj, void* ptr) { new (ptr) Property<float>{&obj->ramp_time}; }
            template<typename T> static inline auto get_ramp_distance(T* obj) { return Property<float>{&obj->ramp_distance}; }
            template<typename T> static inline void get_ramp_distance(T* obj, void* ptr) { new (ptr) Property<float>{&obj->ramp_distance}; }
            template<typename T> static inline auto get_accel(T* obj) { return Property<float>{&obj->accel}; }
            template<typename T> static inline void get_accel(T* obj, void* ptr) { new (ptr) Property<float>{&obj->accel}; }
            template<typename T> static inline auto get_vel(T* obj) { return Property<float>{&obj->vel}; }
            template<typename T> static inline void get_vel(T* obj, void* ptr) { new (ptr) Property<float>{&obj->vel}; }
            template<typename T> static inline auto get_finish_distance(T* obj) { return Property<float>{&obj->finish_distance}; }
            template<typename T> static inline void get_finish_distance(T* obj, void* ptr) { new (ptr) Property<float>{&obj->finish_distance}; }
            template<typename T> static inline auto get_finish_on_vel(T* obj) { return Property<bool>{&obj->finish_on_vel}; }
            template<typename T> static inline void get_finish_on_vel(T* obj, void* ptr) { new (ptr) Property<bool>{&obj->finish_on_vel}; }
            template<typename T> static inline auto get_finish_on_distance(T* obj) { return Property<bool>{&obj->finish_on_distance}; }
            template<typename T> static inline void get_finish_on_distance(T* obj, void* ptr) { new (ptr) Property<bool>{&obj->finish_on_distance}; }
            template<typename T> static inline auto get_finish_on_enc_idx(T* obj) { return Property<bool>{&obj->finish_on_enc_idx}; }
            template<typename T> static inline void get_finish_on_enc_idx(T* obj, void* ptr) { new (ptr) Property<bool>{&obj->finish_on_enc_idx}; }
        };
        class ConfigIntf {
        public:
            class CalibrationLockinIntf {
            public:
                template<typename T> static inline auto get_current(T* obj) { return Property<float>{&obj->current}; }
                template<typename T> static inline void get_current(T* obj, void* ptr) { new (ptr) Property<float>{&obj->current}; }
                template<typename T> static inline auto get_ramp_time(T* obj) { return Property<float>{&obj->ramp_time}; }
                template<typename T> static inline void get_ramp_time(T* obj, void* ptr) { new (ptr) Property<float>{&obj->ramp_time}; }
                template<typename T> static inline auto get_ramp_distance(T* obj) { return Property<float>{&obj->ramp_distance}; }
                template<typename T> static inline void get_ramp_distance(T* obj, void* ptr) { new (ptr) Property<float>{&obj->ramp_distance}; }
                template<typename T> static inline auto get_accel(T* obj) { return Property<float>{&obj->accel}; }
                template<typename T> static inline void get_accel(T* obj, void* ptr) { new (ptr) Property<float>{&obj->accel}; }
                template<typename T> static inline auto get_vel(T* obj) { return Property<float>{&obj->vel}; }
                template<typename T> static inline void get_vel(T* obj, void* ptr) { new (ptr) Property<float>{&obj->vel}; }
            };
            template<typename T> static inline auto get_startup_motor_calibration(T* obj) { return Property<bool>{&obj->startup_motor_calibration}; }
            template<typename T> static inline void get_startup_motor_calibration(T* obj, void* ptr) { new (ptr) Property<bool>{&obj->startup_motor_calibration}; }
            template<typename T> static inline auto get_startup_encoder_index_search(T* obj) { return Property<bool>{&obj->startup_encoder_index_search}; }
            template<typename T> static inline void get_startup_encoder_index_search(T* obj, void* ptr) { new (ptr) Property<bool>{&obj->startup_encoder_index_search}; }
            template<typename T> static inline auto get_startup_encoder_offset_calibration(T* obj) { return Property<bool>{&obj->startup_encoder_offset_calibration}; }
            template<typename T> static inline void get_startup_encoder_offset_calibration(T* obj, void* ptr) { new (ptr) Property<bool>{&obj->startup_encoder_offset_calibration}; }
            template<typename T> static inline auto get_startup_closed_loop_control(T* obj) { return Property<bool>{&obj->startup_closed_loop_control}; }
            template<typename T> static inline void get_startup_closed_loop_control(T* obj, void* ptr) { new (ptr) Property<bool>{&obj->startup_closed_loop_control}; }
            template<typename T> static inline auto get_startup_sensorless_control(T* obj) { return Property<bool>{&obj->startup_sensorless_control}; }
            template<typename T> static inline void get_startup_sensorless_control(T* obj, void* ptr) { new (ptr) Property<bool>{&obj->startup_sensorless_control}; }
            template<typename T> static inline auto get_startup_homing(T* obj) { return Property<bool>{&obj->startup_homing}; }
            template<typename T> static inline void get_startup_homing(T* obj, void* ptr) { new (ptr) Property<bool>{&obj->startup_homing}; }
            template<typename T> static inline auto get_enable_step_dir(T* obj) { return Property<bool>{&obj->enable_step_dir}; }
            template<typename T> static inline void get_enable_step_dir(T* obj, void* ptr) { new (ptr) Property<bool>{&obj->enable_step_dir}; }
            template<typename T> static inline auto get_step_dir_always_on(T* obj) { return Property<bool>{&obj->step_dir_always_on}; }
            template<typename T> static inline void get_step_dir_always_on(T* obj, void* ptr) { new (ptr) Property<bool>{&obj->step_dir_always_on}; }
            template<typename T> static inline auto get_use_enable_pin(T* obj) { return Property<bool>{obj, [](void* ctx){ return (bool)((T*)ctx)->use_enable_pin; }, [](void* ctx, bool value){ ((T*)ctx)->set_use_enable_pin(value); }}; }
            template<typename T> static inline void get_use_enable_pin(T* obj, void* ptr) { new (ptr) Property<bool>{obj, [](void* ctx){ return (bool)((T*)ctx)->use_enable_pin; }, [](void* ctx, bool value){ ((T*)ctx)->set_use_enable_pin(value); }}; }
            template<typename T> static inline auto get_enable_pin_active_low(T* obj) { return Property<bool>{obj, [](void* ctx){ return (bool)((T*)ctx)->enable_pin_active_low; }, [](void* ctx, bool value){ ((T*)ctx)->set_enable_pin_active_low(value); }}; }
            template<typename T> static inline void get_enable_pin_active_low(T* obj, void* ptr) { new (ptr) Property<bool>{obj, [](void* ctx){ return (bool)((T*)ctx)->enable_pin_active_low; }, [](void* ctx, bool value){ ((T*)ctx)->set_enable_pin_active_low(value); }}; }
            template<typename T> static inline auto get_counts_per_step(T* obj) { return Property<float>{&obj->counts_per_step}; }
            template<typename T> static inline void get_counts_per_step(T* obj, void* ptr) { new (ptr) Property<float>{&obj->counts_per_step}; }
            template<typename T> static inline auto get_watchdog_timeout(T* obj) { return Property<float>{&obj->watchdog_timeout}; }
            template<typename T> static inline void get_watchdog_timeout(T* obj, void* ptr) { new (ptr) Property<float>{&obj->watchdog_timeout}; }
            template<typename T> static inline auto get_enable_watchdog(T* obj) { return Property<bool>{&obj->enable_watchdog}; }
            template<typename T> static inline void get_enable_watchdog(T* obj, void* ptr) { new (ptr) Property<bool>{&obj->enable_watchdog}; }
            template<typename T> static inline auto get_step_gpio_pin(T* obj) { return Property<uint16_t>{obj, [](void* ctx){ return (uint16_t)((T*)ctx)->step_gpio_pin; }, [](void* ctx, uint16_t value){ ((T*)ctx)->set_step_gpio_pin(value); }}; }
            template<typename T> static inline void get_step_gpio_pin(T* obj, void* ptr) { new (ptr) Property<uint16_t>{obj, [](void* ctx){ return (uint16_t)((T*)ctx)->step_gpio_pin; }, [](void* ctx, uint16_t value){ ((T*)ctx)->set_step_gpio_pin(value); }}; }
            template<typename T> static inline auto get_dir_gpio_pin(T* obj) { return Property<uint16_t>{obj, [](void* ctx){ return (uint16_t)((T*)ctx)->dir_gpio_pin; }, [](void* ctx, uint16_t value){ ((T*)ctx)->set_dir_gpio_pin(value); }}; }
            template<typename T> static inline void get_dir_gpio_pin(T* obj, void* ptr) { new (ptr) Property<uint16_t>{obj, [](void* ctx){ return (uint16_t)((T*)ctx)->dir_gpio_pin; }, [](void* ctx, uint16_t value){ ((T*)ctx)->set_dir_gpio_pin(value); }}; }
            template<typename T> static inline auto get_en_gpio_pin(T* obj) { return Property<uint16_t>{obj, [](void* ctx){ return (uint16_t)((T*)ctx)->en_gpio_pin; }, [](void* ctx, uint16_t value){ ((T*)ctx)->set_en_gpio_pin(value); }}; }
            template<typename T> static inline void get_en_gpio_pin(T* obj, void* ptr) { new (ptr) Property<uint16_t>{obj, [](void* ctx){ return (uint16_t)((T*)ctx)->en_gpio_pin; }, [](void* ctx, uint16_t value){ ((T*)ctx)->set_en_gpio_pin(value); }}; }
            template<typename T> static inline auto get_calibration_lockin(T* obj) { return &obj->calibration_lockin; }
            template<typename T> static inline auto get_sensorless_ramp(T* obj) { return &obj->sensorless_ramp; }
            template<typename T> static inline auto get_general_lockin(T* obj) { return &obj->general_lockin; }
            template<typename T> static inline auto get_can_node_id(T* obj) { return Property<uint32_t>{&obj->can_node_id}; }
            template<typename T> static inline void get_can_node_id(T* obj, void* ptr) { new (ptr) Property<uint32_t>{&obj->can_node_id}; }
            template<typename T> static inline auto get_can_node_id_extended(T* obj) { return Property<bool>{&obj->can_node_id_extended}; }
            template<typename T> static inline void get_can_node_id_extended(T* obj, void* ptr) { new (ptr) Property<bool>{&obj->can_node_id_extended}; }
            template<typename T> static inline auto get_can_heartbeat_rate_ms(T* obj) { return Property<uint32_t>{&obj->can_heartbeat_rate_ms}; }
            template<typename T> static inline void get_can_heartbeat_rate_ms(T* obj, void* ptr) { new (ptr) Property<uint32_t>{&obj->can_heartbeat_rate_ms}; }
        };
        enum Error {
            ERROR_NONE                       = 0x00000000,
            ERROR_INVALID_STATE              = 0x00000001,
            ERROR_DC_BUS_UNDER_VOLTAGE       = 0x00000002,
            ERROR_DC_BUS_OVER_VOLTAGE        = 0x00000004,
            ERROR_CURRENT_MEASUREMENT_TIMEOUT = 0x00000008,
            ERROR_BRAKE_RESISTOR_DISARMED    = 0x00000010,
            ERROR_MOTOR_DISARMED             = 0x00000020,
            ERROR_MOTOR_FAILED               = 0x00000040,
            ERROR_SENSORLESS_ESTIMATOR_FAILED = 0x00000080,
            ERROR_ENCODER_FAILED             = 0x00000100,
            ERROR_CONTROLLER_FAILED          = 0x00000200,
            ERROR_POS_CTRL_DURING_SENSORLESS = 0x00000400,
            ERROR_WATCHDOG_TIMER_EXPIRED     = 0x00000800,
            ERROR_MIN_ENDSTOP_PRESSED        = 0x00001000,
            ERROR_MAX_ENDSTOP_PRESSED        = 0x00002000,
            ERROR_ESTOP_REQUESTED            = 0x00004000,
            ERROR_HOMING_WITHOUT_ENDSTOP     = 0x00020000,
        };
        enum LockinState {
            LOCKIN_STATE_INACTIVE            = 0,
            LOCKIN_STATE_RAMP                = 1,
            LOCKIN_STATE_ACCELERATE          = 2,
            LOCKIN_STATE_CONST_VEL           = 3,
        };
        enum AxisState {
            AXIS_STATE_UNDEFINED             = 0,
            AXIS_STATE_IDLE                  = 1,
            AXIS_STATE_STARTUP_SEQUENCE      = 2,
            AXIS_STATE_FULL_CALIBRATION_SEQUENCE = 3,
            AXIS_STATE_MOTOR_CALIBRATION     = 4,
            AXIS_STATE_SENSORLESS_CONTROL    = 5,
            AXIS_STATE_ENCODER_INDEX_SEARCH  = 6,
            AXIS_STATE_ENCODER_OFFSET_CALIBRATION = 7,
            AXIS_STATE_CLOSED_LOOP_CONTROL   = 8,
            AXIS_STATE_LOCKIN_SPIN           = 9,
            AXIS_STATE_ENCODER_DIR_FIND      = 10,
            AXIS_STATE_HOMING                = 11,
        };
        template<typename T> static inline auto get_error(T* obj) { return Property<ODriveIntf::AxisIntf::Error>{&obj->error_}; }
        template<typename T> static inline void get_error(T* obj, void* ptr) { new (ptr) Property<ODriveIntf::AxisIntf::Error>{&obj->error_}; }
        template<typename T> static inline auto get_step_dir_active(T* obj) { return Property<const bool>{&obj->step_dir_active_}; }
        template<typename T> static inline void get_step_dir_active(T* obj, void* ptr) { new (ptr) Property<const bool>{&obj->step_dir_active_}; }
        template<typename T> static inline auto get_current_state(T* obj) { return Property<const ODriveIntf::AxisIntf::AxisState>{&obj->current_state_}; }
        template<typename T> static inline void get_current_state(T* obj, void* ptr) { new (ptr) Property<const ODriveIntf::AxisIntf::AxisState>{&obj->current_state_}; }
        template<typename T> static inline auto get_requested_state(T* obj) { return Property<ODriveIntf::AxisIntf::AxisState>{&obj->requested_state_}; }
        template<typename T> static inline void get_requested_state(T* obj, void* ptr) { new (ptr) Property<ODriveIntf::AxisIntf::AxisState>{&obj->requested_state_}; }
        template<typename T> static inline auto get_loop_counter(T* obj) { return Property<const uint32_t>{&obj->loop_counter_}; }
        template<typename T> static inline void get_loop_counter(T* obj, void* ptr) { new (ptr) Property<const uint32_t>{&obj->loop_counter_}; }
        template<typename T> static inline auto get_lockin_state(T* obj) { return Property<const ODriveIntf::AxisIntf::LockinState>{&obj->lockin_state_}; }
        template<typename T> static inline void get_lockin_state(T* obj, void* ptr) { new (ptr) Property<const ODriveIntf::AxisIntf::LockinState>{&obj->lockin_state_}; }
        template<typename T> static inline auto get_is_homed(T* obj) { return Property<bool>{&obj->homing_.is_homed}; }
        template<typename T> static inline void get_is_homed(T* obj, void* ptr) { new (ptr) Property<bool>{&obj->homing_.is_homed}; }
        template<typename T> static inline auto get_config(T* obj) { return &obj->config_; }
        template<typename T> static inline auto get_motor(T* obj) { return &obj->motor_; }
        template<typename T> static inline auto get_controller(T* obj) { return &obj->controller_; }
        template<typename T> static inline auto get_encoder(T* obj) { return &obj->encoder_; }
        template<typename T> static inline auto get_sensorless_estimator(T* obj) { return &obj->sensorless_estimator_; }
        template<typename T> static inline auto get_trap_traj(T* obj) { return &obj->trap_traj_; }
        template<typename T> static inline auto get_min_endstop(T* obj) { return &obj->min_endstop_; }
        template<typename T> static inline auto get_max_endstop(T* obj) { return &obj->max_endstop_; }
        virtual void watchdog_feed() = 0;
        virtual void clear_errors() = 0;
    };
    class MotorIntf {
    public:
        class CurrentControlIntf {
        public:
            template<typename T> static inline auto get_p_gain(T* obj) { return Property<float>{&obj->p_gain}; }
            template<typename T> static inline void get_p_gain(T* obj, void* ptr) { new (ptr) Property<float>{&obj->p_gain}; }
            template<typename T> static inline auto get_i_gain(T* obj) { return Property<float>{&obj->i_gain}; }
            template<typename T> static inline void get_i_gain(T* obj, void* ptr) { new (ptr) Property<float>{&obj->i_gain}; }
            template<typename T> static inline auto get_v_current_control_integral_d(T* obj) { return Property<float>{&obj->v_current_control_integral_d}; }
            template<typename T> static inline void get_v_current_control_integral_d(T* obj, void* ptr) { new (ptr) Property<float>{&obj->v_current_control_integral_d}; }
            template<typename T> static inline auto get_v_current_control_integral_q(T* obj) { return Property<float>{&obj->v_current_control_integral_q}; }
            template<typename T> static inline void get_v_current_control_integral_q(T* obj, void* ptr) { new (ptr) Property<float>{&obj->v_current_control_integral_q}; }
            template<typename T> static inline auto get_Ibus(T* obj) { return Property<float>{&obj->Ibus}; }
            template<typename T> static inline void get_Ibus(T* obj, void* ptr) { new (ptr) Property<float>{&obj->Ibus}; }
            template<typename T> static inline auto get_final_v_alpha(T* obj) { return Property<float>{&obj->final_v_alpha}; }
            template<typename T> static inline void get_final_v_alpha(T* obj, void* ptr) { new (ptr) Property<float>{&obj->final_v_alpha}; }
            template<typename T> static inline auto get_final_v_beta(T* obj) { return Property<float>{&obj->final_v_beta}; }
            template<typename T> static inline void get_final_v_beta(T* obj, void* ptr) { new (ptr) Property<float>{&obj->final_v_beta}; }
            template<typename T> static inline auto get_Id_setpoint(T* obj) { return Property<float>{&obj->Id_setpoint}; }
            template<typename T> static inline void get_Id_setpoint(T* obj, void* ptr) { new (ptr) Property<float>{&obj->Id_setpoint}; }
            template<typename T> static inline auto get_Iq_setpoint(T* obj) { return Property<const float>{&obj->Iq_setpoint}; }
            template<typename T> static inline void get_Iq_setpoint(T* obj, void* ptr) { new (ptr) Property<const float>{&obj->Iq_setpoint}; }
            template<typename T> static inline auto get_Iq_measured(T* obj) { return Property<float>{&obj->Iq_measured}; }
            template<typename T> static inline void get_Iq_measured(T* obj, void* ptr) { new (ptr) Property<float>{&obj->Iq_measured}; }
            template<typename T> static inline auto get_Id_measured(T* obj) { return Property<float>{&obj->Id_measured}; }
            template<typename T> static inline void get_Id_measured(T* obj, void* ptr) { new (ptr) Property<float>{&obj->Id_measured}; }
            template<typename T> static inline auto get_I_measured_report_filter_k(T* obj) { return Property<float>{&obj->I_measured_report_filter_k}; }
            template<typename T> static inline void get_I_measured_report_filter_k(T* obj, void* ptr) { new (ptr) Property<float>{&obj->I_measured_report_filter_k}; }
            template<typename T> static inline auto get_max_allowed_current(T* obj) { return Property<const float>{&obj->max_allowed_current}; }
            template<typename T> static inline void get_max_allowed_current(T* obj, void* ptr) { new (ptr) Property<const float>{&obj->max_allowed_current}; }
            template<typename T> static inline auto get_overcurrent_trip_level(T* obj) { return Property<const float>{&obj->overcurrent_trip_level}; }
            template<typename T> static inline void get_overcurrent_trip_level(T* obj, void* ptr) { new (ptr) Property<const float>{&obj->overcurrent_trip_level}; }
            template<typename T> static inline auto get_acim_rotor_flux(T* obj) { return Property<float>{&obj->acim_rotor_flux}; }
            template<typename T> static inline void get_acim_rotor_flux(T* obj, void* ptr) { new (ptr) Property<float>{&obj->acim_rotor_flux}; }
            template<typename T> static inline auto get_async_phase_vel(T* obj) { return Property<const float>{&obj->async_phase_vel}; }
            template<typename T> static inline void get_async_phase_vel(T* obj, void* ptr) { new (ptr) Property<const float>{&obj->async_phase_vel}; }
            template<typename T> static inline auto get_async_phase_offset(T* obj) { return Property<float>{&obj->async_phase_offset}; }
            template<typename T> static inline void get_async_phase_offset(T* obj, void* ptr) { new (ptr) Property<float>{&obj->async_phase_offset}; }
        };
        class GateDriverIntf {
        public:
            enum DrvFault {
                DRV_FAULT_NO_FAULT               = 0x00000000,
                DRV_FAULT_FET_LOW_C_OVERCURRENT  = 0x00000001,
                DRV_FAULT_FET_HIGH_C_OVERCURRENT = 0x00000002,
                DRV_FAULT_FET_LOW_B_OVERCURRENT  = 0x00000004,
                DRV_FAULT_FET_HIGH_B_OVERCURRENT = 0x00000008,
                DRV_FAULT_FET_LOW_A_OVERCURRENT  = 0x00000010,
                DRV_FAULT_FET_HIGH_A_OVERCURRENT = 0x00000020,
                DRV_FAULT_OVERTEMPERATURE_WARNING = 0x00000040,
                DRV_FAULT_OVERTEMPERATURE_SHUTDOWN = 0x00000080,
                DRV_FAULT_P_VDD_UNDERVOLTAGE     = 0x00000100,
                DRV_FAULT_G_VDD_UNDERVOLTAGE     = 0x00000200,
                DRV_FAULT_G_VDD_OVERVOLTAGE      = 0x00000400,
            };
            template<typename T> static inline auto get_drv_fault(T* obj) { return Property<const ODriveIntf::MotorIntf::GateDriverIntf::DrvFault>{&obj->drv_fault}; }
            template<typename T> static inline void get_drv_fault(T* obj, void* ptr) { new (ptr) Property<const ODriveIntf::MotorIntf::GateDriverIntf::DrvFault>{&obj->drv_fault}; }
        };
        class TimingLogIntf {
        public:
            template<typename T> static inline auto get_general(T* obj) { return Property<const uint16_t>{&obj->get(TIMING_LOG_GENERAL)}; }
            template<typename T> static inline void get_general(T* obj, void* ptr) { new (ptr) Property<const uint16_t>{&obj->get(TIMING_LOG_GENERAL)}; }
            template<typename T> static inline auto get_adc_cb_i(T* obj) { return Property<const uint16_t>{&obj->get(TIMING_LOG_ADC_CB_I)}; }
            template<typename T> static inline void get_adc_cb_i(T* obj, void* ptr) { new (ptr) Property<const uint16_t>{&obj->get(TIMING_LOG_ADC_CB_I)}; }
            template<typename T> static inline auto get_adc_cb_dc(T* obj) { return Property<const uint16_t>{&obj->get(TIMING_LOG_ADC_CB_DC)}; }
            template<typename T> static inline void get_adc_cb_dc(T* obj, void* ptr) { new (ptr) Property<const uint16_t>{&obj->get(TIMING_LOG_ADC_CB_DC)}; }
            template<typename T> static inline auto get_meas_r(T* obj) { return Property<const uint16_t>{&obj->get(TIMING_LOG_MEAS_R)}; }
            template<typename T> static inline void get_meas_r(T* obj, void* ptr) { new (ptr) Property<const uint16_t>{&obj->get(TIMING_LOG_MEAS_R)}; }
            template<typename T> static inline auto get_meas_l(T* obj) { return Property<const uint16_t>{&obj->get(TIMING_LOG_MEAS_L)}; }
            template<typename T> static inline void get_meas_l(T* obj, void* ptr) { new (ptr) Property<const uint16_t>{&obj->get(TIMING_LOG_MEAS_L)}; }
            template<typename T> static inline auto get_enc_calib(T* obj) { return Property<const uint16_t>{&obj->get(TIMING_LOG_ENC_CALIB)}; }
            template<typename T> static inline void get_enc_calib(T* obj, void* ptr) { new (ptr) Property<const uint16_t>{&obj->get(TIMING_LOG_ENC_CALIB)}; }
            template<typename T> static inline auto get_idx_search(T* obj) { return Property<const uint16_t>{&obj->get(TIMING_LOG_IDX_SEARCH)}; }
            template<typename T> static inline void get_idx_search(T* obj, void* ptr) { new (ptr) Property<const uint16_t>{&obj->get(TIMING_LOG_IDX_SEARCH)}; }
            template<typename T> static inline auto get_foc_voltage(T* obj) { return Property<const uint16_t>{&obj->get(TIMING_LOG_FOC_VOLTAGE)}; }
            template<typename T> static inline void get_foc_voltage(T* obj, void* ptr) { new (ptr) Property<const uint16_t>{&obj->get(TIMING_LOG_FOC_VOLTAGE)}; }
            template<typename T> static inline auto get_foc_current(T* obj) { return Property<const uint16_t>{&obj->get(TIMING_LOG_FOC_CURRENT)}; }
            template<typename T> static inline void get_foc_current(T* obj, void* ptr) { new (ptr) Property<const uint16_t>{&obj->get(TIMING_LOG_FOC_CURRENT)}; }
            template<typename T> static inline auto get_spi_start(T* obj) { return Property<const uint16_t>{&obj->get(TIMING_LOG_SPI_START)}; }
            template<typename T> static inline void get_spi_start(T* obj, void* ptr) { new (ptr) Property<const uint16_t>{&obj->get(TIMING_LOG_SPI_START)}; }
            template<typename T> static inline auto get_sample_now(T* obj) { return Property<const uint16_t>{&obj->get(TIMING_LOG_SAMPLE_NOW)}; }
            template<typename T> static inline void get_sample_now(T* obj, void* ptr) { new (ptr) Property<const uint16_t>{&obj->get(TIMING_LOG_SAMPLE_NOW)}; }
            template<typename T> static inline auto get_spi_end(T* obj) { return Property<const uint16_t>{&obj->get(TIMING_LOG_SPI_END)}; }
            template<typename T> static inline void get_spi_end(T* obj, void* ptr) { new (ptr) Property<const uint16_t>{&obj->get(TIMING_LOG_SPI_END)}; }
        };
        class ConfigIntf {
        public:
            template<typename T> static inline auto get_pre_calibrated(T* obj) { return Property<bool>{obj, [](void* ctx){ return (bool)((T*)ctx)->pre_calibrated; }, [](void* ctx, bool value){ ((T*)ctx)->set_pre_calibrated(value); }}; }
            template<typename T> static inline void get_pre_calibrated(T* obj, void* ptr) { new (ptr) Property<bool>{obj, [](void* ctx){ return (bool)((T*)ctx)->pre_calibrated; }, [](void* ctx, bool value){ ((T*)ctx)->set_pre_calibrated(value); }}; }
            template<typename T> static inline auto get_pole_pairs(T* obj) { return Property<int32_t>{&obj->pole_pairs}; }
            template<typename T> static inline void get_pole_pairs(T* obj, void* ptr) { new (ptr) Property<int32_t>{&obj->pole_pairs}; }
            template<typename T> static inline auto get_calibration_current(T* obj) { return Property<float>{&obj->calibration_current}; }
            template<typename T> static inline void get_calibration_current(T* obj, void* ptr) { new (ptr) Property<float>{&obj->calibration_current}; }
            template<typename T> static inline auto get_resistance_calib_max_voltage(T* obj) { return Property<float>{&obj->resistance_calib_max_voltage}; }
            template<typename T> static inline void get_resistance_calib_max_voltage(T* obj, void* ptr) { new (ptr) Property<float>{&obj->resistance_calib_max_voltage}; }
            template<typename T> static inline auto get_phase_inductance(T* obj) { return Property<float>{obj, [](void* ctx){ return (float)((T*)ctx)->phase_inductance; }, [](void* ctx, float value){ ((T*)ctx)->set_phase_inductance(value); }}; }
            template<typename T> static inline void get_phase_inductance(T* obj, void* ptr) { new (ptr) Property<float>{obj, [](void* ctx){ return (float)((T*)ctx)->phase_inductance; }, [](void* ctx, float value){ ((T*)ctx)->set_phase_inductance(value); }}; }
            template<typename T> static inline auto get_phase_resistance(T* obj) { return Property<float>{obj, [](void* ctx){ return (float)((T*)ctx)->phase_resistance; }, [](void* ctx, float value){ ((T*)ctx)->set_phase_resistance(value); }}; }
            template<typename T> static inline void get_phase_resistance(T* obj, void* ptr) { new (ptr) Property<float>{obj, [](void* ctx){ return (float)((T*)ctx)->phase_resistance; }, [](void* ctx, float value){ ((T*)ctx)->set_phase_resistance(value); }}; }
            template<typename T> static inline auto get_direction(T* obj) { return Property<int32_t>{&obj->direction}; }
            template<typename T> static inline void get_direction(T* obj, void* ptr) { new (ptr) Property<int32_t>{&obj->direction}; }
            template<typename T> static inline auto get_motor_type(T* obj) { return Property<ODriveIntf::MotorIntf::MotorType>{&obj->motor_type}; }
            template<typename T> static inline void get_motor_type(T* obj, void* ptr) { new (ptr) Property<ODriveIntf::MotorIntf::MotorType>{&obj->motor_type}; }
            template<typename T> static inline auto get_current_lim(T* obj) { return Property<float>{&obj->current_lim}; }
            template<typename T> static inline void get_current_lim(T* obj, void* ptr) { new (ptr) Property<float>{&obj->current_lim}; }
            template<typename T> static inline auto get_current_lim_margin(T* obj) { return Property<float>{&obj->current_lim_margin}; }
            template<typename T> static inline void get_current_lim_margin(T* obj, void* ptr) { new (ptr) Property<float>{&obj->current_lim_margin}; }
            template<typename T> static inline auto get_inverter_temp_limit_lower(T* obj) { return Property<float>{&obj->inverter_temp_limit_lower}; }
            template<typename T> static inline void get_inverter_temp_limit_lower(T* obj, void* ptr) { new (ptr) Property<float>{&obj->inverter_temp_limit_lower}; }
            template<typename T> static inline auto get_inverter_temp_limit_upper(T* obj) { return Property<float>{&obj->inverter_temp_limit_upper}; }
            template<typename T> static inline void get_inverter_temp_limit_upper(T* obj, void* ptr) { new (ptr) Property<float>{&obj->inverter_temp_limit_upper}; }
            template<typename T> static inline auto get_requested_current_range(T* obj) { return Property<float>{&obj->requested_current_range}; }
            template<typename T> static inline void get_requested_current_range(T* obj, void* ptr) { new (ptr) Property<float>{&obj->requested_current_range}; }
            template<typename T> static inline auto get_current_control_bandwidth(T* obj) { return Property<float>{obj, [](void* ctx){ return (float)((T*)ctx)->current_control_bandwidth; }, [](void* ctx, float value){ ((T*)ctx)->set_current_control_bandwidth(value); }}; }
            template<typename T> static inline void get_current_control_bandwidth(T* obj, void* ptr) { new (ptr) Property<float>{obj, [](void* ctx){ return (float)((T*)ctx)->current_control_bandwidth; }, [](void* ctx, float value){ ((T*)ctx)->set_current_control_bandwidth(value); }}; }
            template<typename T> static inline auto get_acim_slip_velocity(T* obj) { return Property<float>{&obj->acim_slip_velocity}; }
            template<typename T> static inline void get_acim_slip_velocity(T* obj, void* ptr) { new (ptr) Property<float>{&obj->acim_slip_velocity}; }
            template<typename T> static inline auto get_acim_gain_min_flux(T* obj) { return Property<float>{&obj->acim_gain_min_flux}; }
            template<typename T> static inline void get_acim_gain_min_flux(T* obj, void* ptr) { new (ptr) Property<float>{&obj->acim_gain_min_flux}; }
            template<typename T> static inline auto get_acim_autoflux_min_Id(T* obj) { return Property<float>{&obj->acim_autoflux_min_Id}; }
            template<typename T> static inline void get_acim_autoflux_min_Id(T* obj, void* ptr) { new (ptr) Property<float>{&obj->acim_autoflux_min_Id}; }
            template<typename T> static inline auto get_acim_autoflux_enable(T* obj) { return Property<bool>{&obj->acim_autoflux_enable}; }
            template<typename T> static inline void get_acim_autoflux_enable(T* obj, void* ptr) { new (ptr) Property<bool>{&obj->acim_autoflux_enable}; }
            template<typename T> static inline auto get_acim_autoflux_attack_gain(T* obj) { return Property<float>{&obj->acim_autoflux_attack_gain}; }
            template<typename T> static inline void get_acim_autoflux_attack_gain(T* obj, void* ptr) { new (ptr) Property<float>{&obj->acim_autoflux_attack_gain}; }
            template<typename T> static inline auto get_acim_autoflux_decay_gain(T* obj) { return Property<float>{&obj->acim_autoflux_decay_gain}; }
            template<typename T> static inline void get_acim_autoflux_decay_gain(T* obj, void* ptr) { new (ptr) Property<float>{&obj->acim_autoflux_decay_gain}; }
        };
        enum Error {
            ERROR_NONE                       = 0x00000000,
            ERROR_PHASE_RESISTANCE_OUT_OF_RANGE = 0x00000001,
            ERROR_PHASE_INDUCTANCE_OUT_OF_RANGE = 0x00000002,
            ERROR_ADC_FAILED                 = 0x00000004,
            ERROR_DRV_FAULT                  = 0x00000008,
            ERROR_CONTROL_DEADLINE_MISSED    = 0x00000010,
            ERROR_NOT_IMPLEMENTED_MOTOR_TYPE = 0x00000020,
            ERROR_BRAKE_CURRENT_OUT_OF_RANGE = 0x00000040,
            ERROR_MODULATION_MAGNITUDE       = 0x00000080,
            ERROR_BRAKE_DEADTIME_VIOLATION   = 0x00000100,
            ERROR_UNEXPECTED_TIMER_CALLBACK  = 0x00000200,
            ERROR_CURRENT_SENSE_SATURATION   = 0x00000400,
            ERROR_INVERTER_OVER_TEMP         = 0x00000800,
            ERROR_CURRENT_LIMIT_VIOLATION    = 0x00001000,
            ERROR_BRAKE_DUTY_CYCLE_NAN       = 0x00002000,
            ERROR_DC_BUS_OVER_REGEN_CURRENT  = 0x00004000,
            ERROR_DC_BUS_OVER_CURRENT        = 0x00008000,
        };
        enum ArmedState {
            ARMED_STATE_DISARMED             = 0,
            ARMED_STATE_WAITING_FOR_TIMINGS  = 1,
            ARMED_STATE_WAITING_FOR_UPDATE   = 2,
            ARMED_STATE_ARMED                = 3,
        };
        enum MotorType {
            MOTOR_TYPE_HIGH_CURRENT          = 0,
            MOTOR_TYPE_GIMBAL                = 2,
            MOTOR_TYPE_ACIM                  = 3,
        };
        template<typename T> static inline auto get_error(T* obj) { return Property<ODriveIntf::MotorIntf::Error>{&obj->error_}; }
        template<typename T> static inline void get_error(T* obj, void* ptr) { new (ptr) Property<ODriveIntf::MotorIntf::Error>{&obj->error_}; }
        template<typename T> static inline auto get_armed_state(T* obj) { return Property<const ODriveIntf::MotorIntf::ArmedState>{&obj->armed_state_}; }
        template<typename T> static inline void get_armed_state(T* obj, void* ptr) { new (ptr) Property<const ODriveIntf::MotorIntf::ArmedState>{&obj->armed_state_}; }
        template<typename T> static inline auto get_is_calibrated(T* obj) { return Property<const bool>{&obj->is_calibrated_}; }
        template<typename T> static inline void get_is_calibrated(T* obj, void* ptr) { new (ptr) Property<const bool>{&obj->is_calibrated_}; }
        template<typename T> static inline auto get_current_meas_phB(T* obj) { return Property<const float>{&obj->current_meas_.phB}; }
        template<typename T> static inline void get_current_meas_phB(T* obj, void* ptr) { new (ptr) Property<const float>{&obj->current_meas_.phB}; }
        template<typename T> static inline auto get_current_meas_phC(T* obj) { return Property<const float>{&obj->current_meas_.phC}; }
        template<typename T> static inline void get_current_meas_phC(T* obj, void* ptr) { new (ptr) Property<const float>{&obj->current_meas_.phC}; }
        template<typename T> static inline auto get_DC_calib_phB(T* obj) { return Property<float>{&obj->DC_calib_.phB}; }
        template<typename T> static inline void get_DC_calib_phB(T* obj, void* ptr) { new (ptr) Property<float>{&obj->DC_calib_.phB}; }
        template<typename T> static inline auto get_DC_calib_phC(T* obj) { return Property<float>{&obj->DC_calib_.phC}; }
        template<typename T> static inline void get_DC_calib_phC(T* obj, void* ptr) { new (ptr) Property<float>{&obj->DC_calib_.phC}; }
        template<typename T> static inline auto get_phase_current_rev_gain(T* obj) { return Property<float>{&obj->phase_current_rev_gain_}; }
        template<typename T> static inline void get_phase_current_rev_gain(T* obj, void* ptr) { new (ptr) Property<float>{&obj->phase_current_rev_gain_}; }
        template<typename T> static inline auto get_thermal_current_lim(T* obj) { return Property<const float>{&obj->thermal_current_lim_}; }
        template<typename T> static inline void get_thermal_current_lim(T* obj, void* ptr) { new (ptr) Property<const float>{&obj->thermal_current_lim_}; }
        template<typename T> static inline auto get_inverter_temp(T* obj) { return Property<const float>{&obj->inverter_temp_}; }
        template<typename T> static inline void get_inverter_temp(T* obj, void* ptr) { new (ptr) Property<const float>{&obj->inverter_temp_}; }
        template<typename T> static inline auto get_current_control(T* obj) { return &obj->current_control_; }
        template<typename T> static inline auto get_gate_driver(T* obj) { return &obj->gate_driver_exported_; }
        template<typename T> static inline auto get_timing_log(T* obj) { return &obj->timing_log_; }
        template<typename T> static inline auto get_config(T* obj) { return &obj->config_; }
    };
    class ControllerIntf {
    public:
        class ConfigIntf {
        public:
            class AnticoggingIntf {
            public:
                template<typename T> static inline auto get_index(T* obj) { return Property<const uint32_t>{&obj->index}; }
                template<typename T> static inline void get_index(T* obj, void* ptr) { new (ptr) Property<const uint32_t>{&obj->index}; }
                template<typename T> static inline auto get_pre_calibrated(T* obj) { return Property<bool>{&obj->pre_calibrated}; }
                template<typename T> static inline void get_pre_calibrated(T* obj, void* ptr) { new (ptr) Property<bool>{&obj->pre_calibrated}; }
                template<typename T> static inline auto get_calib_anticogging(T* obj) { return Property<const bool>{&obj->calib_anticogging}; }
                template<typename T> static inline void get_calib_anticogging(T* obj, void* ptr) { new (ptr) Property<const bool>{&obj->calib_anticogging}; }
                template<typename T> static inline auto get_calib_pos_threshold(T* obj) { return Property<float>{&obj->calib_pos_threshold}; }
                template<typename T> static inline void get_calib_pos_threshold(T* obj, void* ptr) { new (ptr) Property<float>{&obj->calib_pos_threshold}; }
                template<typename T> static inline auto get_calib_vel_threshold(T* obj) { return Property<float>{&obj->calib_vel_threshold}; }
                template<typename T> static inline void get_calib_vel_threshold(T* obj, void* ptr) { new (ptr) Property<float>{&obj->calib_vel_threshold}; }
                template<typename T> static inline auto get_cogging_ratio(T* obj) { return Property<const float>{&obj->cogging_ratio}; }
                template<typename T> static inline void get_cogging_ratio(T* obj, void* ptr) { new (ptr) Property<const float>{&obj->cogging_ratio}; }
                template<typename T> static inline auto get_anticogging_enabled(T* obj) { return Property<bool>{&obj->anticogging_enabled}; }
                template<typename T> static inline void get_anticogging_enabled(T* obj, void* ptr) { new (ptr) Property<bool>{&obj->anticogging_enabled}; }
            };
            template<typename T> static inline auto get_gain_scheduling_width(T* obj) { return Property<float>{&obj->gain_scheduling_width}; }
            template<typename T> static inline void get_gain_scheduling_width(T* obj, void* ptr) { new (ptr) Property<float>{&obj->gain_scheduling_width}; }
            template<typename T> static inline auto get_enable_vel_limit(T* obj) { return Property<bool>{&obj->enable_vel_limit}; }
            template<typename T> static inline void get_enable_vel_limit(T* obj, void* ptr) { new (ptr) Property<bool>{&obj->enable_vel_limit}; }
            template<typename T> static inline auto get_enable_current_mode_vel_limit(T* obj) { return Property<bool>{&obj->enable_current_mode_vel_limit}; }
            template<typename T> static inline void get_enable_current_mode_vel_limit(T* obj, void* ptr) { new (ptr) Property<bool>{&obj->enable_current_mode_vel_limit}; }
            template<typename T> static inline auto get_enable_gain_scheduling(T* obj) { return Property<bool>{&obj->enable_gain_scheduling}; }
            template<typename T> static inline void get_enable_gain_scheduling(T* obj, void* ptr) { new (ptr) Property<bool>{&obj->enable_gain_scheduling}; }
            template<typename T> static inline auto get_enable_overspeed_error(T* obj) { return Property<bool>{&obj->enable_overspeed_error}; }
            template<typename T> static inline void get_enable_overspeed_error(T* obj, void* ptr) { new (ptr) Property<bool>{&obj->enable_overspeed_error}; }
            template<typename T> static inline auto get_control_mode(T* obj) { return Property<ODriveIntf::ControllerIntf::ControlMode>{&obj->control_mode}; }
            template<typename T> static inline void get_control_mode(T* obj, void* ptr) { new (ptr) Property<ODriveIntf::ControllerIntf::ControlMode>{&obj->control_mode}; }
            template<typename T> static inline auto get_input_mode(T* obj) { return Property<ODriveIntf::ControllerIntf::InputMode>{&obj->input_mode}; }
            template<typename T> static inline void get_input_mode(T* obj, void* ptr) { new (ptr) Property<ODriveIntf::ControllerIntf::InputMode>{&obj->input_mode}; }
            template<typename T> static inline auto get_pos_gain(T* obj) { return Property<float>{&obj->pos_gain}; }
            template<typename T> static inline void get_pos_gain(T* obj, void* ptr) { new (ptr) Property<float>{&obj->pos_gain}; }
            template<typename T> static inline auto get_vel_gain(T* obj) { return Property<float>{&obj->vel_gain}; }
            template<typename T> static inline void get_vel_gain(T* obj, void* ptr) { new (ptr) Property<float>{&obj->vel_gain}; }
            template<typename T> static inline auto get_vel_integrator_gain(T* obj) { return Property<float>{&obj->vel_integrator_gain}; }
            template<typename T> static inline void get_vel_integrator_gain(T* obj, void* ptr) { new (ptr) Property<float>{&obj->vel_integrator_gain}; }
            template<typename T> static inline auto get_vel_limit(T* obj) { return Property<float>{&obj->vel_limit}; }
            template<typename T> static inline void get_vel_limit(T* obj, void* ptr) { new (ptr) Property<float>{&obj->vel_limit}; }
            template<typename T> static inline auto get_vel_limit_tolerance(T* obj) { return Property<float>{&obj->vel_limit_tolerance}; }
            template<typename T> static inline void get_vel_limit_tolerance(T* obj, void* ptr) { new (ptr) Property<float>{&obj->vel_limit_tolerance}; }
            template<typename T> static inline auto get_vel_ramp_rate(T* obj) { return Property<float>{&obj->vel_ramp_rate}; }
            template<typename T> static inline void get_vel_ramp_rate(T* obj, void* ptr) { new (ptr) Property<float>{&obj->vel_ramp_rate}; }
            template<typename T> static inline auto get_current_ramp_rate(T* obj) { return Property<float>{&obj->current_ramp_rate}; }
            template<typename T> static inline void get_current_ramp_rate(T* obj, void* ptr) { new (ptr) Property<float>{&obj->current_ramp_rate}; }
            template<typename T> static inline auto get_homing_speed(T* obj) { return Property<float>{&obj->homing_speed}; }
            template<typename T> static inline void get_homing_speed(T* obj, void* ptr) { new (ptr) Property<float>{&obj->homing_speed}; }
            template<typename T> static inline auto get_inertia(T* obj) { return Property<float>{&obj->inertia}; }
            template<typename T> static inline void get_inertia(T* obj, void* ptr) { new (ptr) Property<float>{&obj->inertia}; }
            template<typename T> static inline auto get_axis_to_mirror(T* obj) { return Property<uint8_t>{&obj->axis_to_mirror}; }
            template<typename T> static inline void get_axis_to_mirror(T* obj, void* ptr) { new (ptr) Property<uint8_t>{&obj->axis_to_mirror}; }
            template<typename T> static inline auto get_mirror_ratio(T* obj) { return Property<float>{&obj->mirror_ratio}; }
            template<typename T> static inline void get_mirror_ratio(T* obj, void* ptr) { new (ptr) Property<float>{&obj->mirror_ratio}; }
            template<typename T> static inline auto get_load_encoder_axis(T* obj) { return Property<uint8_t>{&obj->load_encoder_axis}; }
            template<typename T> static inline void get_load_encoder_axis(T* obj, void* ptr) { new (ptr) Property<uint8_t>{&obj->load_encoder_axis}; }
            template<typename T> static inline auto get_input_filter_bandwidth(T* obj) { return Property<float>{obj, [](void* ctx){ return (float)((T*)ctx)->input_filter_bandwidth; }, [](void* ctx, float value){ ((T*)ctx)->set_input_filter_bandwidth(value); }}; }
            template<typename T> static inline void get_input_filter_bandwidth(T* obj, void* ptr) { new (ptr) Property<float>{obj, [](void* ctx){ return (float)((T*)ctx)->input_filter_bandwidth; }, [](void* ctx, float value){ ((T*)ctx)->set_input_filter_bandwidth(value); }}; }
            template<typename T> static inline auto get_anticogging(T* obj) { return &obj->anticogging; }
        };
        enum Error {
            ERROR_NONE                       = 0x00000000,
            ERROR_OVERSPEED                  = 0x00000001,
            ERROR_INVALID_INPUT_MODE         = 0x00000002,
            ERROR_UNSTABLE_GAIN              = 0x00000004,
            ERROR_INVALID_MIRROR_AXIS        = 0x00000008,
            ERROR_INVALID_LOAD_ENCODER       = 0x00000010,
            ERROR_INVALID_ESTIMATE           = 0x00000020,
        };
        enum ControlMode {
            CONTROL_MODE_VOLTAGE_CONTROL     = 0,
            CONTROL_MODE_CURRENT_CONTROL     = 1,
            CONTROL_MODE_VELOCITY_CONTROL    = 2,
            CONTROL_MODE_POSITION_CONTROL    = 3,
        };
        enum InputMode {
            INPUT_MODE_INACTIVE              = 0,
            INPUT_MODE_PASSTHROUGH           = 1,
            INPUT_MODE_VEL_RAMP              = 2,
            INPUT_MODE_POS_FILTER            = 3,
            INPUT_MODE_MIX_CHANNELS          = 4,
            INPUT_MODE_TRAP_TRAJ             = 5,
            INPUT_MODE_CURRENT_RAMP          = 6,
            INPUT_MODE_MIRROR                = 7,
        };
        template<typename T> static inline auto get_error(T* obj) { return Property<ODriveIntf::ControllerIntf::Error>{&obj->error_}; }
        template<typename T> static inline void get_error(T* obj, void* ptr) { new (ptr) Property<ODriveIntf::ControllerIntf::Error>{&obj->error_}; }
        template<typename T> static inline auto get_input_pos(T* obj) { return Property<float>{obj, [](void* ctx){ return (float)((T*)ctx)->input_pos_; }, [](void* ctx, float value){ ((T*)ctx)->set_input_pos(value); }}; }
        template<typename T> static inline void get_input_pos(T* obj, void* ptr) { new (ptr) Property<float>{obj, [](void* ctx){ return (float)((T*)ctx)->input_pos_; }, [](void* ctx, float value){ ((T*)ctx)->set_input_pos(value); }}; }
        template<typename T> static inline auto get_input_vel(T* obj) { return Property<float>{&obj->input_vel_}; }
        template<typename T> static inline void get_input_vel(T* obj, void* ptr) { new (ptr) Property<float>{&obj->input_vel_}; }
        template<typename T> static inline auto get_input_current(T* obj) { return Property<float>{&obj->input_current_}; }
        template<typename T> static inline void get_input_current(T* obj, void* ptr) { new (ptr) Property<float>{&obj->input_current_}; }
        template<typename T> static inline auto get_pos_setpoint(T* obj) { return Property<const float>{&obj->pos_setpoint_}; }
        template<typename T> static inline void get_pos_setpoint(T* obj, void* ptr) { new (ptr) Property<const float>{&obj->pos_setpoint_}; }
        template<typename T> static inline auto get_vel_setpoint(T* obj) { return Property<const float>{&obj->vel_setpoint_}; }
        template<typename T> static inline void get_vel_setpoint(T* obj, void* ptr) { new (ptr) Property<const float>{&obj->vel_setpoint_}; }
        template<typename T> static inline auto get_current_setpoint(T* obj) { return Property<const float>{&obj->current_setpoint_}; }
        template<typename T> static inline void get_current_setpoint(T* obj, void* ptr) { new (ptr) Property<const float>{&obj->current_setpoint_}; }
        template<typename T> static inline auto get_trajectory_done(T* obj) { return Property<const bool>{&obj->trajectory_done_}; }
        template<typename T> static inline void get_trajectory_done(T* obj, void* ptr) { new (ptr) Property<const bool>{&obj->trajectory_done_}; }
        template<typename T> static inline auto get_vel_integrator_current(T* obj) { return Property<float>{&obj->vel_integrator_current_}; }
        template<typename T> static inline void get_vel_integrator_current(T* obj, void* ptr) { new (ptr) Property<float>{&obj->vel_integrator_current_}; }
        template<typename T> static inline auto get_anticogging_valid(T* obj) { return Property<bool>{&obj->anticogging_valid_}; }
        template<typename T> static inline void get_anticogging_valid(T* obj, void* ptr) { new (ptr) Property<bool>{&obj->anticogging_valid_}; }
        template<typename T> static inline auto get_config(T* obj) { return &obj->config_; }
        virtual void move_incremental(float displacement, bool from_input_pos) = 0;
        virtual void start_anticogging_calibration() = 0;
        float move_incremental_in_displacement_; // for internal use by Fibre
        template<typename T> static auto get_move_incremental_in_displacement_(T* obj) { return Property<float>{&obj->move_incremental_in_displacement_}; }
        template<typename T> static void get_move_incremental_in_displacement_(T* obj, void* ptr) { new (ptr) Property<float>{&obj->move_incremental_in_displacement_}; }
        bool move_incremental_in_from_input_pos_; // for internal use by Fibre
        template<typename T> static auto get_move_incremental_in_from_input_pos_(T* obj) { return Property<bool>{&obj->move_incremental_in_from_input_pos_}; }
        template<typename T> static void get_move_incremental_in_from_input_pos_(T* obj, void* ptr) { new (ptr) Property<bool>{&obj->move_incremental_in_from_input_pos_}; }
    };
    class EncoderIntf {
    public:
        class ConfigIntf {
        public:
            template<typename T> static inline auto get_mode(T* obj) { return Property<ODriveIntf::EncoderIntf::Mode>{&obj->mode}; }
            template<typename T> static inline void get_mode(T* obj, void* ptr) { new (ptr) Property<ODriveIntf::EncoderIntf::Mode>{&obj->mode}; }
            template<typename T> static inline auto get_use_index(T* obj) { return Property<bool>{obj, [](void* ctx){ return (bool)((T*)ctx)->use_index; }, [](void* ctx, bool value){ ((T*)ctx)->set_use_index(value); }}; }
            template<typename T> static inline void get_use_index(T* obj, void* ptr) { new (ptr) Property<bool>{obj, [](void* ctx){ return (bool)((T*)ctx)->use_index; }, [](void* ctx, bool value){ ((T*)ctx)->set_use_index(value); }}; }
            template<typename T> static inline auto get_find_idx_on_lockin_only(T* obj) { return Property<bool>{obj, [](void* ctx){ return (bool)((T*)ctx)->find_idx_on_lockin_only; }, [](void* ctx, bool value){ ((T*)ctx)->set_find_idx_on_lockin_only(value); }}; }
            template<typename T> static inline void get_find_idx_on_lockin_only(T* obj, void* ptr) { new (ptr) Property<bool>{obj, [](void* ctx){ return (bool)((T*)ctx)->find_idx_on_lockin_only; }, [](void* ctx, bool value){ ((T*)ctx)->set_find_idx_on_lockin_only(value); }}; }
            template<typename T> static inline auto get_abs_spi_cs_gpio_pin(T* obj) { return Property<uint16_t>{obj, [](void* ctx){ return (uint16_t)((T*)ctx)->abs_spi_cs_gpio_pin; }, [](void* ctx, uint16_t value){ ((T*)ctx)->set_abs_spi_cs_gpio_pin(value); }}; }
            template<typename T> static inline void get_abs_spi_cs_gpio_pin(T* obj, void* ptr) { new (ptr) Property<uint16_t>{obj, [](void* ctx){ return (uint16_t)((T*)ctx)->abs_spi_cs_gpio_pin; }, [](void* ctx, uint16_t value){ ((T*)ctx)->set_abs_spi_cs_gpio_pin(value); }}; }
            template<typename T> static inline auto get_zero_count_on_find_idx(T* obj) { return Property<bool>{&obj->zero_count_on_find_idx}; }
            template<typename T> static inline void get_zero_count_on_find_idx(T* obj, void* ptr) { new (ptr) Property<bool>{&obj->zero_count_on_find_idx}; }
            template<typename T> static inline auto get_cpr(T* obj) { return Property<int32_t>{&obj->cpr}; }
            template<typename T> static inline void get_cpr(T* obj, void* ptr) { new (ptr) Property<int32_t>{&obj->cpr}; }
            template<typename T> static inline auto get_offset(T* obj) { return Property<int32_t>{&obj->offset}; }
            template<typename T> static inline void get_offset(T* obj, void* ptr) { new (ptr) Property<int32_t>{&obj->offset}; }
            template<typename T> static inline auto get_pre_calibrated(T* obj) { return Property<bool>{obj, [](void* ctx){ return (bool)((T*)ctx)->pre_calibrated; }, [](void* ctx, bool value){ ((T*)ctx)->set_pre_calibrated(value); }}; }
            template<typename T> static inline void get_pre_calibrated(T* obj, void* ptr) { new (ptr) Property<bool>{obj, [](void* ctx){ return (bool)((T*)ctx)->pre_calibrated; }, [](void* ctx, bool value){ ((T*)ctx)->set_pre_calibrated(value); }}; }
            template<typename T> static inline auto get_offset_float(T* obj) { return Property<float>{&obj->offset_float}; }
            template<typename T> static inline void get_offset_float(T* obj, void* ptr) { new (ptr) Property<float>{&obj->offset_float}; }
            template<typename T> static inline auto get_enable_phase_interpolation(T* obj) { return Property<bool>{&obj->enable_phase_interpolation}; }
            template<typename T> static inline void get_enable_phase_interpolation(T* obj, void* ptr) { new (ptr) Property<bool>{&obj->enable_phase_interpolation}; }
            template<typename T> static inline auto get_bandwidth(T* obj) { return Property<float>{obj, [](void* ctx){ return (float)((T*)ctx)->bandwidth; }, [](void* ctx, float value){ ((T*)ctx)->set_bandwidth(value); }}; }
            template<typename T> static inline void get_bandwidth(T* obj, void* ptr) { new (ptr) Property<float>{obj, [](void* ctx){ return (float)((T*)ctx)->bandwidth; }, [](void* ctx, float value){ ((T*)ctx)->set_bandwidth(value); }}; }
            template<typename T> static inline auto get_calib_range(T* obj) { return Property<float>{&obj->calib_range}; }
            template<typename T> static inline void get_calib_range(T* obj, void* ptr) { new (ptr) Property<float>{&obj->calib_range}; }
            template<typename T> static inline auto get_calib_scan_distance(T* obj) { return Property<float>{&obj->calib_scan_distance}; }
            template<typename T> static inline void get_calib_scan_distance(T* obj, void* ptr) { new (ptr) Property<float>{&obj->calib_scan_distance}; }
            template<typename T> static inline auto get_calib_scan_omega(T* obj) { return Property<float>{&obj->calib_scan_omega}; }
            template<typename T> static inline void get_calib_scan_omega(T* obj, void* ptr) { new (ptr) Property<float>{&obj->calib_scan_omega}; }
            template<typename T> static inline auto get_idx_search_unidirectional(T* obj) { return Property<bool>{&obj->idx_search_unidirectional}; }
            template<typename T> static inline void get_idx_search_unidirectional(T* obj, void* ptr) { new (ptr) Property<bool>{&obj->idx_search_unidirectional}; }
            template<typename T> static inline auto get_ignore_illegal_hall_state(T* obj) { return Property<bool>{&obj->ignore_illegal_hall_state}; }
            template<typename T> static inline void get_ignore_illegal_hall_state(T* obj, void* ptr) { new (ptr) Property<bool>{&obj->ignore_illegal_hall_state}; }
            template<typename T> static inline auto get_sincos_gpio_pin_sin(T* obj) { return Property<uint16_t>{&obj->sincos_gpio_pin_sin}; }
            template<typename T> static inline void get_sincos_gpio_pin_sin(T* obj, void* ptr) { new (ptr) Property<uint16_t>{&obj->sincos_gpio_pin_sin}; }
            template<typename T> static inline auto get_sincos_gpio_pin_cos(T* obj) { return Property<uint16_t>{&obj->sincos_gpio_pin_cos}; }
            template<typename T> static inline void get_sincos_gpio_pin_cos(T* obj, void* ptr) { new (ptr) Property<uint16_t>{&obj->sincos_gpio_pin_cos}; }
        };
        enum Error {
            ERROR_NONE                       = 0x00000000,
            ERROR_UNSTABLE_GAIN              = 0x00000001,
            ERROR_CPR_POLEPAIRS_MISMATCH     = 0x00000002,
            ERROR_NO_RESPONSE                = 0x00000004,
            ERROR_UNSUPPORTED_ENCODER_MODE   = 0x00000008,
            ERROR_ILLEGAL_HALL_STATE         = 0x00000010,
            ERROR_INDEX_NOT_FOUND_YET        = 0x00000020,
            ERROR_ABS_SPI_TIMEOUT            = 0x00000040,
            ERROR_ABS_SPI_COM_FAIL           = 0x00000080,
            ERROR_ABS_SPI_NOT_READY          = 0x00000100,
        };
        enum Mode {
            MODE_INCREMENTAL                 = 0,
            MODE_HALL                        = 1,
            MODE_SINCOS                      = 2,
            MODE_SPI_ABS_CUI                 = 256,
            MODE_SPI_ABS_AMS                 = 257,
            MODE_SPI_ABS_AEAT                = 258,
        };
        template<typename T> static inline auto get_error(T* obj) { return Property<ODriveIntf::EncoderIntf::Error>{&obj->error_}; }
        template<typename T> static inline void get_error(T* obj, void* ptr) { new (ptr) Property<ODriveIntf::EncoderIntf::Error>{&obj->error_}; }
        template<typename T> static inline auto get_is_ready(T* obj) { return Property<const bool>{&obj->is_ready_}; }
        template<typename T> static inline void get_is_ready(T* obj, void* ptr) { new (ptr) Property<const bool>{&obj->is_ready_}; }
        template<typename T> static inline auto get_index_found(T* obj) { return Property<const bool>{&obj->index_found_}; }
        template<typename T> static inline void get_index_found(T* obj, void* ptr) { new (ptr) Property<const bool>{&obj->index_found_}; }
        template<typename T> static inline auto get_shadow_count(T* obj) { return Property<const int32_t>{&obj->shadow_count_}; }
        template<typename T> static inline void get_shadow_count(T* obj, void* ptr) { new (ptr) Property<const int32_t>{&obj->shadow_count_}; }
        template<typename T> static inline auto get_count_in_cpr(T* obj) { return Property<const int32_t>{&obj->count_in_cpr_}; }
        template<typename T> static inline void get_count_in_cpr(T* obj, void* ptr) { new (ptr) Property<const int32_t>{&obj->count_in_cpr_}; }
        template<typename T> static inline auto get_interpolation(T* obj) { return Property<const float>{&obj->interpolation_}; }
        template<typename T> static inline void get_interpolation(T* obj, void* ptr) { new (ptr) Property<const float>{&obj->interpolation_}; }
        template<typename T> static inline auto get_phase(T* obj) { return Property<const float>{&obj->phase_}; }
        template<typename T> static inline void get_phase(T* obj, void* ptr) { new (ptr) Property<const float>{&obj->phase_}; }
        template<typename T> static inline auto get_pos_estimate(T* obj) { return Property<const float>{&obj->pos_estimate_}; }
        template<typename T> static inline void get_pos_estimate(T* obj, void* ptr) { new (ptr) Property<const float>{&obj->pos_estimate_}; }
        template<typename T> static inline auto get_pos_cpr(T* obj) { return Property<const float>{&obj->pos_cpr_}; }
        template<typename T> static inline void get_pos_cpr(T* obj, void* ptr) { new (ptr) Property<const float>{&obj->pos_cpr_}; }
        template<typename T> static inline auto get_hall_state(T* obj) { return Property<const uint8_t>{&obj->hall_state_}; }
        template<typename T> static inline void get_hall_state(T* obj, void* ptr) { new (ptr) Property<const uint8_t>{&obj->hall_state_}; }
        template<typename T> static inline auto get_vel_estimate(T* obj) { return Property<const float>{&obj->vel_estimate_}; }
        template<typename T> static inline void get_vel_estimate(T* obj, void* ptr) { new (ptr) Property<const float>{&obj->vel_estimate_}; }
        template<typename T> static inline auto get_calib_scan_response(T* obj) { return Property<const float>{&obj->calib_scan_response_}; }
        template<typename T> static inline void get_calib_scan_response(T* obj, void* ptr) { new (ptr) Property<const float>{&obj->calib_scan_response_}; }
        template<typename T> static inline auto get_pos_abs(T* obj) { return Property<int32_t>{&obj->pos_abs_}; }
        template<typename T> static inline void get_pos_abs(T* obj, void* ptr) { new (ptr) Property<int32_t>{&obj->pos_abs_}; }
        template<typename T> static inline auto get_spi_error_rate(T* obj) { return Property<const float>{&obj->spi_error_rate_}; }
        template<typename T> static inline void get_spi_error_rate(T* obj, void* ptr) { new (ptr) Property<const float>{&obj->spi_error_rate_}; }
        template<typename T> static inline auto get_config(T* obj) { return &obj->config_; }
        virtual void set_linear_count(int32_t count) = 0;
        int32_t set_linear_count_in_count_; // for internal use by Fibre
        template<typename T> static auto get_set_linear_count_in_count_(T* obj) { return Property<int32_t>{&obj->set_linear_count_in_count_}; }
        template<typename T> static void get_set_linear_count_in_count_(T* obj, void* ptr) { new (ptr) Property<int32_t>{&obj->set_linear_count_in_count_}; }
    };
    class SensorlessEstimatorIntf {
    public:
        class ConfigIntf {
        public:
            template<typename T> static inline auto get_observer_gain(T* obj) { return Property<float>{&obj->observer_gain}; }
            template<typename T> static inline void get_observer_gain(T* obj, void* ptr) { new (ptr) Property<float>{&obj->observer_gain}; }
            template<typename T> static inline auto get_pll_bandwidth(T* obj) { return Property<float>{&obj->pll_bandwidth}; }
            template<typename T> static inline void get_pll_bandwidth(T* obj, void* ptr) { new (ptr) Property<float>{&obj->pll_bandwidth}; }
            template<typename T> static inline auto get_pm_flux_linkage(T* obj) { return Property<float>{&obj->pm_flux_linkage}; }
            template<typename T> static inline void get_pm_flux_linkage(T* obj, void* ptr) { new (ptr) Property<float>{&obj->pm_flux_linkage}; }
        };
        enum Error {
            ERROR_NONE                       = 0x00000000,
            ERROR_UNSTABLE_GAIN              = 0x00000001,
        };
        template<typename T> static inline auto get_error(T* obj) { return Property<ODriveIntf::SensorlessEstimatorIntf::Error>{&obj->error_}; }
        template<typename T> static inline void get_error(T* obj, void* ptr) { new (ptr) Property<ODriveIntf::SensorlessEstimatorIntf::Error>{&obj->error_}; }
        template<typename T> static inline auto get_phase(T* obj) { return Property<float>{&obj->phase_}; }
        template<typename T> static inline void get_phase(T* obj, void* ptr) { new (ptr) Property<float>{&obj->phase_}; }
        template<typename T> static inline auto get_pll_pos(T* obj) { return Property<float>{&obj->pll_pos_}; }
        template<typename T> static inline void get_pll_pos(T* obj, void* ptr) { new (ptr) Property<float>{&obj->pll_pos_}; }
        template<typename T> static inline auto get_vel_estimate(T* obj) { return Property<float>{&obj->vel_estimate_}; }
        template<typename T> static inline void get_vel_estimate(T* obj, void* ptr) { new (ptr) Property<float>{&obj->vel_estimate_}; }
        template<typename T> static inline auto get_config(T* obj) { return &obj->config_; }
    };
    class TrapezoidalTrajectoryIntf {
    public:
        class ConfigIntf {
        public:
            template<typename T> static inline auto get_vel_limit(T* obj) { return Property<float>{&obj->vel_limit}; }
            template<typename T> static inline void get_vel_limit(T* obj, void* ptr) { new (ptr) Property<float>{&obj->vel_limit}; }
            template<typename T> static inline auto get_accel_limit(T* obj) { return Property<float>{&obj->accel_limit}; }
            template<typename T> static inline void get_accel_limit(T* obj, void* ptr) { new (ptr) Property<float>{&obj->accel_limit}; }
            template<typename T> static inline auto get_decel_limit(T* obj) { return Property<float>{&obj->decel_limit}; }
            template<typename T> static inline void get_decel_limit(T* obj, void* ptr) { new (ptr) Property<float>{&obj->decel_limit}; }
        };
        template<typename T> static inline auto get_config(T* obj) { return &obj->config_; }
    };
    class EndstopIntf {
    public:
        class ConfigIntf {
        public:
            template<typename T> static inline auto get_gpio_num(T* obj) { return Property<uint16_t>{obj, [](void* ctx){ return (uint16_t)((T*)ctx)->gpio_num; }, [](void* ctx, uint16_t value){ ((T*)ctx)->set_gpio_num(value); }}; }
            template<typename T> static inline void get_gpio_num(T* obj, void* ptr) { new (ptr) Property<uint16_t>{obj, [](void* ctx){ return (uint16_t)((T*)ctx)->gpio_num; }, [](void* ctx, uint16_t value){ ((T*)ctx)->set_gpio_num(value); }}; }
            template<typename T> static inline auto get_enabled(T* obj) { return Property<bool>{obj, [](void* ctx){ return (bool)((T*)ctx)->enabled; }, [](void* ctx, bool value){ ((T*)ctx)->set_enabled(value); }}; }
            template<typename T> static inline void get_enabled(T* obj, void* ptr) { new (ptr) Property<bool>{obj, [](void* ctx){ return (bool)((T*)ctx)->enabled; }, [](void* ctx, bool value){ ((T*)ctx)->set_enabled(value); }}; }
            template<typename T> static inline auto get_offset(T* obj) { return Property<float>{&obj->offset}; }
            template<typename T> static inline void get_offset(T* obj, void* ptr) { new (ptr) Property<float>{&obj->offset}; }
            template<typename T> static inline auto get_is_active_high(T* obj) { return Property<bool>{&obj->is_active_high}; }
            template<typename T> static inline void get_is_active_high(T* obj, void* ptr) { new (ptr) Property<bool>{&obj->is_active_high}; }
            template<typename T> static inline auto get_pullup(T* obj) { return Property<bool>{&obj->pullup}; }
            template<typename T> static inline void get_pullup(T* obj, void* ptr) { new (ptr) Property<bool>{&obj->pullup}; }
            template<typename T> static inline auto get_debounce_ms(T* obj) { return Property<uint32_t>{obj, [](void* ctx){ return (uint32_t)((T*)ctx)->debounce_ms; }, [](void* ctx, uint32_t value){ ((T*)ctx)->set_debounce_ms(value); }}; }
            template<typename T> static inline void get_debounce_ms(T* obj, void* ptr) { new (ptr) Property<uint32_t>{obj, [](void* ctx){ return (uint32_t)((T*)ctx)->debounce_ms; }, [](void* ctx, uint32_t value){ ((T*)ctx)->set_debounce_ms(value); }}; }
        };
        template<typename T> static inline auto get_endstop_state(T* obj) { return Property<const bool>{&obj->endstop_state_}; }
        template<typename T> static inline void get_endstop_state(T* obj, void* ptr) { new (ptr) Property<const bool>{&obj->endstop_state_}; }
        template<typename T> static inline auto get_config(T* obj) { return &obj->config_; }
    };
    class SystemStatsIntf {
    public:
        class UsbIntf {
        public:
            template<typename T> static inline auto get_rx_cnt(T* obj) { return Property<const uint32_t>{&obj->rx_cnt}; }
            template<typename T> static inline void get_rx_cnt(T* obj, void* ptr) { new (ptr) Property<const uint32_t>{&obj->rx_cnt}; }
            template<typename T> static inline auto get_tx_cnt(T* obj) { return Property<const uint32_t>{&obj->tx_cnt}; }
            template<typename T> static inline void get_tx_cnt(T* obj, void* ptr) { new (ptr) Property<const uint32_t>{&obj->tx_cnt}; }
            template<typename T> static inline auto get_tx_overrun_cnt(T* obj) { return Property<const uint32_t>{&obj->tx_overrun_cnt}; }
            template<typename T> static inline void get_tx_overrun_cnt(T* obj, void* ptr) { new (ptr) Property<const uint32_t>{&obj->tx_overrun_cnt}; }
        };
        class I2CIntf {
        public:
            template<typename T> static inline auto get_addr(T* obj) { return Property<const uint8_t>{&obj->addr}; }
            template<typename T> static inline void get_addr(T* obj, void* ptr) { new (ptr) Property<const uint8_t>{&obj->addr}; }
            template<typename T> static inline auto get_addr_match_cnt(T* obj) { return Property<const uint32_t>{&obj->addr_match_cnt}; }
            template<typename T> static inline void get_addr_match_cnt(T* obj, void* ptr) { new (ptr) Property<const uint32_t>{&obj->addr_match_cnt}; }
            template<typename T> static inline auto get_rx_cnt(T* obj) { return Property<const uint32_t>{&obj->rx_cnt}; }
            template<typename T> static inline void get_rx_cnt(T* obj, void* ptr) { new (ptr) Property<const uint32_t>{&obj->rx_cnt}; }
            template<typename T> static inline auto get_error_cnt(T* obj) { return Property<const uint32_t>{&obj->error_cnt}; }
            template<typename T> static inline void get_error_cnt(T* obj, void* ptr) { new (ptr) Property<const uint32_t>{&obj->error_cnt}; }
        };
        template<typename T> static inline auto get_uptime(T* obj) { return Property<const uint32_t>{&obj->uptime}; }
        template<typename T> static inline void get_uptime(T* obj, void* ptr) { new (ptr) Property<const uint32_t>{&obj->uptime}; }
        template<typename T> static inline auto get_min_heap_space(T* obj) { return Property<const uint32_t>{&obj->min_heap_space}; }
        template<typename T> static inline void get_min_heap_space(T* obj, void* ptr) { new (ptr) Property<const uint32_t>{&obj->min_heap_space}; }
        template<typename T> static inline auto get_min_stack_space_axis0(T* obj) { return Property<const uint32_t>{&obj->min_stack_space_axis0}; }
        template<typename T> static inline void get_min_stack_space_axis0(T* obj, void* ptr) { new (ptr) Property<const uint32_t>{&obj->min_stack_space_axis0}; }
        template<typename T> static inline auto get_min_stack_space_axis1(T* obj) { return Property<const uint32_t>{&obj->min_stack_space_axis1}; }
        template<typename T> static inline void get_min_stack_space_axis1(T* obj, void* ptr) { new (ptr) Property<const uint32_t>{&obj->min_stack_space_axis1}; }
        template<typename T> static inline auto get_min_stack_space_comms(T* obj) { return Property<const uint32_t>{&obj->min_stack_space_comms}; }
        template<typename T> static inline void get_min_stack_space_comms(T* obj, void* ptr) { new (ptr) Property<const uint32_t>{&obj->min_stack_space_comms}; }
        template<typename T> static inline auto get_min_stack_space_usb(T* obj) { return Property<const uint32_t>{&obj->min_stack_space_usb}; }
        template<typename T> static inline void get_min_stack_space_usb(T* obj, void* ptr) { new (ptr) Property<const uint32_t>{&obj->min_stack_space_usb}; }
        template<typename T> static inline auto get_min_stack_space_uart(T* obj) { return Property<const uint32_t>{&obj->min_stack_space_uart}; }
        template<typename T> static inline void get_min_stack_space_uart(T* obj, void* ptr) { new (ptr) Property<const uint32_t>{&obj->min_stack_space_uart}; }
        template<typename T> static inline auto get_min_stack_space_can(T* obj) { return Property<const uint32_t>{&obj->min_stack_space_can}; }
        template<typename T> static inline void get_min_stack_space_can(T* obj, void* ptr) { new (ptr) Property<const uint32_t>{&obj->min_stack_space_can}; }
        template<typename T> static inline auto get_min_stack_space_usb_irq(T* obj) { return Property<const uint32_t>{&obj->min_stack_space_usb_irq}; }
        template<typename T> static inline void get_min_stack_space_usb_irq(T* obj, void* ptr) { new (ptr) Property<const uint32_t>{&obj->min_stack_space_usb_irq}; }
        template<typename T> static inline auto get_min_stack_space_startup(T* obj) { return Property<const uint32_t>{&obj->min_stack_space_startup}; }
        template<typename T> static inline void get_min_stack_space_startup(T* obj, void* ptr) { new (ptr) Property<const uint32_t>{&obj->min_stack_space_startup}; }
        template<typename T> static inline auto get_stack_usage_axis0(T* obj) { return Property<const uint32_t>{&obj->stack_usage_axis0}; }
        template<typename T> static inline void get_stack_usage_axis0(T* obj, void* ptr) { new (ptr) Property<const uint32_t>{&obj->stack_usage_axis0}; }
        template<typename T> static inline auto get_stack_usage_axis1(T* obj) { return Property<const uint32_t>{&obj->stack_usage_axis1}; }
        template<typename T> static inline void get_stack_usage_axis1(T* obj, void* ptr) { new (ptr) Property<const uint32_t>{&obj->stack_usage_axis1}; }
        template<typename T> static inline auto get_stack_usage_comms(T* obj) { return Property<const uint32_t>{&obj->stack_usage_comms}; }
        template<typename T> static inline void get_stack_usage_comms(T* obj, void* ptr) { new (ptr) Property<const uint32_t>{&obj->stack_usage_comms}; }
        template<typename T> static inline auto get_stack_usage_usb(T* obj) { return Property<const uint32_t>{&obj->stack_usage_usb}; }
        template<typename T> static inline void get_stack_usage_usb(T* obj, void* ptr) { new (ptr) Property<const uint32_t>{&obj->stack_usage_usb}; }
        template<typename T> static inline auto get_stack_usage_uart(T* obj) { return Property<const uint32_t>{&obj->stack_usage_uart}; }
        template<typename T> static inline void get_stack_usage_uart(T* obj, void* ptr) { new (ptr) Property<const uint32_t>{&obj->stack_usage_uart}; }
        template<typename T> static inline auto get_stack_usage_usb_irq(T* obj) { return Property<const uint32_t>{&obj->stack_usage_usb_irq}; }
        template<typename T> static inline void get_stack_usage_usb_irq(T* obj, void* ptr) { new (ptr) Property<const uint32_t>{&obj->stack_usage_usb_irq}; }
        template<typename T> static inline auto get_stack_usage_startup(T* obj) { return Property<const uint32_t>{&obj->stack_usage_startup}; }
        template<typename T> static inline void get_stack_usage_startup(T* obj, void* ptr) { new (ptr) Property<const uint32_t>{&obj->stack_usage_startup}; }
        template<typename T> static inline auto get_stack_usage_can(T* obj) { return Property<const uint32_t>{&obj->stack_usage_can}; }
        template<typename T> static inline void get_stack_usage_can(T* obj, void* ptr) { new (ptr) Property<const uint32_t>{&obj->stack_usage_can}; }
        template<typename T> static inline auto get_usb(T* obj) { return &obj->usb; }
        template<typename T> static inline auto get_i2c(T* obj) { return &obj->i2c; }
    };
    class ConfigIntf {
    public:
        template<typename T> static inline auto get_enable_uart(T* obj) { return Property<bool>{&obj->enable_uart}; }
        template<typename T> static inline void get_enable_uart(T* obj, void* ptr) { new (ptr) Property<bool>{&obj->enable_uart}; }
        template<typename T> static inline auto get_uart_baudrate(T* obj) { return Property<uint32_t>{&obj->uart_baudrate}; }
        template<typename T> static inline void get_uart_baudrate(T* obj, void* ptr) { new (ptr) Property<uint32_t>{&obj->uart_baudrate}; }
        template<typename T> static inline auto get_enable_i2c_instead_of_can(T* obj) { return Property<bool>{&obj->enable_i2c_instead_of_can}; }
        template<typename T> static inline void get_enable_i2c_instead_of_can(T* obj, void* ptr) { new (ptr) Property<bool>{&obj->enable_i2c_instead_of_can}; }
        template<typename T> static inline auto get_enable_ascii_protocol_on_usb(T* obj) { return Property<bool>{&obj->enable_ascii_protocol_on_usb}; }
        template<typename T> static inline void get_enable_ascii_protocol_on_usb(T* obj, void* ptr) { new (ptr) Property<bool>{&obj->enable_ascii_protocol_on_usb}; }
        template<typename T> static inline auto get_max_regen_current(T* obj) { return Property<float>{&obj->max_regen_current}; }
        template<typename T> static inline void get_max_regen_current(T* obj, void* ptr) { new (ptr) Property<float>{&obj->max_regen_current}; }
        template<typename T> static inline auto get_brake_resistance(T* obj) { return Property<float>{&obj->brake_resistance}; }
        template<typename T> static inline void get_brake_resistance(T* obj, void* ptr) { new (ptr) Property<float>{&obj->brake_resistance}; }
        template<typename T> static inline auto get_dc_bus_undervoltage_trip_level(T* obj) { return Property<float>{&obj->dc_bus_undervoltage_trip_level}; }
        template<typename T> static inline void get_dc_bus_undervoltage_trip_level(T* obj, void* ptr) { new (ptr) Property<float>{&obj->dc_bus_undervoltage_trip_level}; }
        template<typename T> static inline auto get_dc_bus_overvoltage_trip_level(T* obj) { return Property<float>{&obj->dc_bus_overvoltage_trip_level}; }
        template<typename T> static inline void get_dc_bus_overvoltage_trip_level(T* obj, void* ptr) { new (ptr) Property<float>{&obj->dc_bus_overvoltage_trip_level}; }
        template<typename T> static inline auto get_enable_dc_bus_overvoltage_ramp(T* obj) { return Property<bool>{&obj->enable_dc_bus_overvoltage_ramp}; }
        template<typename T> static inline void get_enable_dc_bus_overvoltage_ramp(T* obj, void* ptr) { new (ptr) Property<bool>{&obj->enable_dc_bus_overvoltage_ramp}; }
        template<typename T> static inline auto get_dc_bus_overvoltage_ramp_start(T* obj) { return Property<float>{&obj->dc_bus_overvoltage_ramp_start}; }
        template<typename T> static inline void get_dc_bus_overvoltage_ramp_start(T* obj, void* ptr) { new (ptr) Property<float>{&obj->dc_bus_overvoltage_ramp_start}; }
        template<typename T> static inline auto get_dc_bus_overvoltage_ramp_end(T* obj) { return Property<float>{&obj->dc_bus_overvoltage_ramp_end}; }
        template<typename T> static inline void get_dc_bus_overvoltage_ramp_end(T* obj, void* ptr) { new (ptr) Property<float>{&obj->dc_bus_overvoltage_ramp_end}; }
        template<typename T> static inline auto get_dc_max_positive_current(T* obj) { return Property<float>{&obj->dc_max_positive_current}; }
        template<typename T> static inline void get_dc_max_positive_current(T* obj, void* ptr) { new (ptr) Property<float>{&obj->dc_max_positive_current}; }
        template<typename T> static inline auto get_dc_max_negative_current(T* obj) { return Property<float>{&obj->dc_max_negative_current}; }
        template<typename T> static inline void get_dc_max_negative_current(T* obj, void* ptr) { new (ptr) Property<float>{&obj->dc_max_negative_current}; }
        template<typename T> static inline auto get_gpio1_pwm_mapping(T* obj) { return &obj->pwm_mappings[0]; }
        template<typename T> static inline auto get_gpio2_pwm_mapping(T* obj) { return &obj->pwm_mappings[1]; }
        template<typename T> static inline auto get_gpio3_pwm_mapping(T* obj) { return &obj->pwm_mappings[2]; }
        template<typename T> static inline auto get_gpio4_pwm_mapping(T* obj) { return &obj->pwm_mappings[3]; }
        template<typename T> static inline auto get_gpio3_analog_mapping(T* obj) { return &obj->analog_mappings[2]; }
        template<typename T> static inline auto get_gpio4_analog_mapping(T* obj) { return &obj->analog_mappings[3]; }
    };
    template<typename T> static inline auto get_vbus_voltage(T* obj) { return Property<const float>{&obj->vbus_voltage_}; }
    template<typename T> static inline void get_vbus_voltage(T* obj, void* ptr) { new (ptr) Property<const float>{&obj->vbus_voltage_}; }
    template<typename T> static inline auto get_ibus(T* obj) { return Property<const float>{&obj->ibus_}; }
    template<typename T> static inline void get_ibus(T* obj, void* ptr) { new (ptr) Property<const float>{&obj->ibus_}; }
    template<typename T> static inline auto get_serial_number(T* obj) { return Property<const uint64_t>{&obj->serial_number_}; }
    template<typename T> static inline void get_serial_number(T* obj, void* ptr) { new (ptr) Property<const uint64_t>{&obj->serial_number_}; }
    template<typename T> static inline auto get_hw_version_major(T* obj) { return Property<const uint8_t>{&obj->hw_version_major_}; }
    template<typename T> static inline void get_hw_version_major(T* obj, void* ptr) { new (ptr) Property<const uint8_t>{&obj->hw_version_major_}; }
    template<typename T> static inline auto get_hw_version_minor(T* obj) { return Property<const uint8_t>{&obj->hw_version_minor_}; }
    template<typename T> static inline void get_hw_version_minor(T* obj, void* ptr) { new (ptr) Property<const uint8_t>{&obj->hw_version_minor_}; }
    template<typename T> static inline auto get_hw_version_variant(T* obj) { return Property<const uint8_t>{&obj->hw_version_variant_}; }
    template<typename T> static inline void get_hw_version_variant(T* obj, void* ptr) { new (ptr) Property<const uint8_t>{&obj->hw_version_variant_}; }
    template<typename T> static inline auto get_fw_version_major(T* obj) { return Property<const uint8_t>{&obj->fw_version_major_}; }
    template<typename T> static inline void get_fw_version_major(T* obj, void* ptr) { new (ptr) Property<const uint8_t>{&obj->fw_version_major_}; }
    template<typename T> static inline auto get_fw_version_minor(T* obj) { return Property<const uint8_t>{&obj->fw_version_minor_}; }
    template<typename T> static inline void get_fw_version_minor(T* obj, void* ptr) { new (ptr) Property<const uint8_t>{&obj->fw_version_minor_}; }
    template<typename T> static inline auto get_fw_version_revision(T* obj) { return Property<const uint8_t>{&obj->fw_version_revision_}; }
    template<typename T> static inline void get_fw_version_revision(T* obj, void* ptr) { new (ptr) Property<const uint8_t>{&obj->fw_version_revision_}; }
    template<typename T> static inline auto get_fw_version_unreleased(T* obj) { return Property<const uint8_t>{&obj->fw_version_unreleased_}; }
    template<typename T> static inline void get_fw_version_unreleased(T* obj, void* ptr) { new (ptr) Property<const uint8_t>{&obj->fw_version_unreleased_}; }
    template<typename T> static inline auto get_brake_resistor_armed(T* obj) { return Property<const bool>{&obj->brake_resistor_armed_}; }
    template<typename T> static inline void get_brake_resistor_armed(T* obj, void* ptr) { new (ptr) Property<const bool>{&obj->brake_resistor_armed_}; }
    template<typename T> static inline auto get_brake_resistor_saturated(T* obj) { return Property<bool>{&obj->brake_resistor_saturated_}; }
    template<typename T> static inline void get_brake_resistor_saturated(T* obj, void* ptr) { new (ptr) Property<bool>{&obj->brake_resistor_saturated_}; }
    template<typename T> static inline auto get_system_stats(T* obj) { return &obj->system_stats_; }
    template<typename T> static inline auto get_config(T* obj) { return &obj->config_; }
    template<typename T> static inline auto get_user_config_loaded(T* obj) { return Property<const bool>{&obj->user_config_loaded_}; }
    template<typename T> static inline void get_user_config_loaded(T* obj, void* ptr) { new (ptr) Property<const bool>{&obj->user_config_loaded_}; }
    template<typename T> static inline auto get_axis0(T* obj) { return &obj->get_axis(0); }
    template<typename T> static inline auto get_axis1(T* obj) { return &obj->get_axis(1); }
    template<typename T> static inline auto get_can(T* obj) { return &obj->get_can(); }
    template<typename T> static inline auto get_test_property(T* obj) { return Property<uint32_t>{&obj->test_property_}; }
    template<typename T> static inline void get_test_property(T* obj, void* ptr) { new (ptr) Property<uint32_t>{&obj->test_property_}; }
    virtual int32_t test_function(int32_t delta) = 0;
    virtual float get_oscilloscope_val(uint32_t index) = 0;
    virtual float get_adc_voltage(uint32_t gpio) = 0;
    virtual void save_configuration() = 0;
    virtual void erase_configuration() = 0;
    virtual void reboot() = 0;
    virtual void enter_dfu_mode() = 0;
    int32_t test_function_in_delta_; // for internal use by Fibre
    template<typename T> static auto get_test_function_in_delta_(T* obj) { return Property<int32_t>{&obj->test_function_in_delta_}; }
    template<typename T> static void get_test_function_in_delta_(T* obj, void* ptr) { new (ptr) Property<int32_t>{&obj->test_function_in_delta_}; }
    int32_t test_function_out_cnt_; // for internal use by Fibre
    template<typename T> static auto get_test_function_out_cnt_(T* obj) { return Property<const int32_t>{&obj->test_function_out_cnt_}; }
    template<typename T> static void get_test_function_out_cnt_(T* obj, void* ptr) { new (ptr) Property<const int32_t>{&obj->test_function_out_cnt_}; }
    uint32_t get_oscilloscope_val_in_index_; // for internal use by Fibre
    template<typename T> static auto get_get_oscilloscope_val_in_index_(T* obj) { return Property<uint32_t>{&obj->get_oscilloscope_val_in_index_}; }
    template<typename T> static void get_get_oscilloscope_val_in_index_(T* obj, void* ptr) { new (ptr) Property<uint32_t>{&obj->get_oscilloscope_val_in_index_}; }
    float get_oscilloscope_val_out_val_; // for internal use by Fibre
    template<typename T> static auto get_get_oscilloscope_val_out_val_(T* obj) { return Property<const float>{&obj->get_oscilloscope_val_out_val_}; }
    template<typename T> static void get_get_oscilloscope_val_out_val_(T* obj, void* ptr) { new (ptr) Property<const float>{&obj->get_oscilloscope_val_out_val_}; }
    uint32_t get_adc_voltage_in_gpio_; // for internal use by Fibre
    template<typename T> static auto get_get_adc_voltage_in_gpio_(T* obj) { return Property<uint32_t>{&obj->get_adc_voltage_in_gpio_}; }
    template<typename T> static void get_get_adc_voltage_in_gpio_(T* obj, void* ptr) { new (ptr) Property<uint32_t>{&obj->get_adc_voltage_in_gpio_}; }
    float get_adc_voltage_out_voltage_; // for internal use by Fibre
    template<typename T> static auto get_get_adc_voltage_out_voltage_(T* obj) { return Property<const float>{&obj->get_adc_voltage_out_voltage_}; }
    template<typename T> static void get_get_adc_voltage_out_voltage_(T* obj, void* ptr) { new (ptr) Property<const float>{&obj->get_adc_voltage_out_voltage_}; }
};

// this is technically not thread-safe but practically it might be
inline ODriveIntf::CanIntf::Error operator | (ODriveIntf::CanIntf::Error a, ODriveIntf::CanIntf::Error b) { return static_cast<ODriveIntf::CanIntf::Error>(static_cast<std::underlying_type_t<ODriveIntf::CanIntf::Error>>(a) | static_cast<std::underlying_type_t<ODriveIntf::CanIntf::Error>>(b)); }
inline ODriveIntf::CanIntf::Error operator & (ODriveIntf::CanIntf::Error a, ODriveIntf::CanIntf::Error b) { return static_cast<ODriveIntf::CanIntf::Error>(static_cast<std::underlying_type_t<ODriveIntf::CanIntf::Error>>(a) & static_cast<std::underlying_type_t<ODriveIntf::CanIntf::Error>>(b)); }
inline ODriveIntf::CanIntf::Error operator ^ (ODriveIntf::CanIntf::Error a, ODriveIntf::CanIntf::Error b) { return static_cast<ODriveIntf::CanIntf::Error>(static_cast<std::underlying_type_t<ODriveIntf::CanIntf::Error>>(a) ^ static_cast<std::underlying_type_t<ODriveIntf::CanIntf::Error>>(b)); }
inline ODriveIntf::CanIntf::Error& operator |= (ODriveIntf::CanIntf::Error &a, ODriveIntf::CanIntf::Error b) { return reinterpret_cast<ODriveIntf::CanIntf::Error&>(reinterpret_cast<std::underlying_type_t<ODriveIntf::CanIntf::Error>&>(a) |= static_cast<std::underlying_type_t<ODriveIntf::CanIntf::Error>>(b)); }
inline ODriveIntf::CanIntf::Error& operator &= (ODriveIntf::CanIntf::Error &a, ODriveIntf::CanIntf::Error b) { return reinterpret_cast<ODriveIntf::CanIntf::Error&>(reinterpret_cast<std::underlying_type_t<ODriveIntf::CanIntf::Error>&>(a) &= static_cast<std::underlying_type_t<ODriveIntf::CanIntf::Error>>(b)); }
inline ODriveIntf::CanIntf::Error& operator ^= (ODriveIntf::CanIntf::Error &a, ODriveIntf::CanIntf::Error b) { return reinterpret_cast<ODriveIntf::CanIntf::Error&>(reinterpret_cast<std::underlying_type_t<ODriveIntf::CanIntf::Error>&>(a) ^= static_cast<std::underlying_type_t<ODriveIntf::CanIntf::Error>>(b)); }
inline ODriveIntf::CanIntf::Error operator ~ (ODriveIntf::CanIntf::Error a) { return static_cast<ODriveIntf::CanIntf::Error>(~static_cast<std::underlying_type_t<ODriveIntf::CanIntf::Error>>(a)); }
// this is technically not thread-safe but practically it might be
inline ODriveIntf::AxisIntf::Error operator | (ODriveIntf::AxisIntf::Error a, ODriveIntf::AxisIntf::Error b) { return static_cast<ODriveIntf::AxisIntf::Error>(static_cast<std::underlying_type_t<ODriveIntf::AxisIntf::Error>>(a) | static_cast<std::underlying_type_t<ODriveIntf::AxisIntf::Error>>(b)); }
inline ODriveIntf::AxisIntf::Error operator & (ODriveIntf::AxisIntf::Error a, ODriveIntf::AxisIntf::Error b) { return static_cast<ODriveIntf::AxisIntf::Error>(static_cast<std::underlying_type_t<ODriveIntf::AxisIntf::Error>>(a) & static_cast<std::underlying_type_t<ODriveIntf::AxisIntf::Error>>(b)); }
inline ODriveIntf::AxisIntf::Error operator ^ (ODriveIntf::AxisIntf::Error a, ODriveIntf::AxisIntf::Error b) { return static_cast<ODriveIntf::AxisIntf::Error>(static_cast<std::underlying_type_t<ODriveIntf::AxisIntf::Error>>(a) ^ static_cast<std::underlying_type_t<ODriveIntf::AxisIntf::Error>>(b)); }
inline ODriveIntf::AxisIntf::Error& operator |= (ODriveIntf::AxisIntf::Error &a, ODriveIntf::AxisIntf::Error b) { return reinterpret_cast<ODriveIntf::AxisIntf::Error&>(reinterpret_cast<std::underlying_type_t<ODriveIntf::AxisIntf::Error>&>(a) |= static_cast<std::underlying_type_t<ODriveIntf::AxisIntf::Error>>(b)); }
inline ODriveIntf::AxisIntf::Error& operator &= (ODriveIntf::AxisIntf::Error &a, ODriveIntf::AxisIntf::Error b) { return reinterpret_cast<ODriveIntf::AxisIntf::Error&>(reinterpret_cast<std::underlying_type_t<ODriveIntf::AxisIntf::Error>&>(a) &= static_cast<std::underlying_type_t<ODriveIntf::AxisIntf::Error>>(b)); }
inline ODriveIntf::AxisIntf::Error& operator ^= (ODriveIntf::AxisIntf::Error &a, ODriveIntf::AxisIntf::Error b) { return reinterpret_cast<ODriveIntf::AxisIntf::Error&>(reinterpret_cast<std::underlying_type_t<ODriveIntf::AxisIntf::Error>&>(a) ^= static_cast<std::underlying_type_t<ODriveIntf::AxisIntf::Error>>(b)); }
inline ODriveIntf::AxisIntf::Error operator ~ (ODriveIntf::AxisIntf::Error a) { return static_cast<ODriveIntf::AxisIntf::Error>(~static_cast<std::underlying_type_t<ODriveIntf::AxisIntf::Error>>(a)); }
// this is technically not thread-safe but practically it might be
inline ODriveIntf::MotorIntf::Error operator | (ODriveIntf::MotorIntf::Error a, ODriveIntf::MotorIntf::Error b) { return static_cast<ODriveIntf::MotorIntf::Error>(static_cast<std::underlying_type_t<ODriveIntf::MotorIntf::Error>>(a) | static_cast<std::underlying_type_t<ODriveIntf::MotorIntf::Error>>(b)); }
inline ODriveIntf::MotorIntf::Error operator & (ODriveIntf::MotorIntf::Error a, ODriveIntf::MotorIntf::Error b) { return static_cast<ODriveIntf::MotorIntf::Error>(static_cast<std::underlying_type_t<ODriveIntf::MotorIntf::Error>>(a) & static_cast<std::underlying_type_t<ODriveIntf::MotorIntf::Error>>(b)); }
inline ODriveIntf::MotorIntf::Error operator ^ (ODriveIntf::MotorIntf::Error a, ODriveIntf::MotorIntf::Error b) { return static_cast<ODriveIntf::MotorIntf::Error>(static_cast<std::underlying_type_t<ODriveIntf::MotorIntf::Error>>(a) ^ static_cast<std::underlying_type_t<ODriveIntf::MotorIntf::Error>>(b)); }
inline ODriveIntf::MotorIntf::Error& operator |= (ODriveIntf::MotorIntf::Error &a, ODriveIntf::MotorIntf::Error b) { return reinterpret_cast<ODriveIntf::MotorIntf::Error&>(reinterpret_cast<std::underlying_type_t<ODriveIntf::MotorIntf::Error>&>(a) |= static_cast<std::underlying_type_t<ODriveIntf::MotorIntf::Error>>(b)); }
inline ODriveIntf::MotorIntf::Error& operator &= (ODriveIntf::MotorIntf::Error &a, ODriveIntf::MotorIntf::Error b) { return reinterpret_cast<ODriveIntf::MotorIntf::Error&>(reinterpret_cast<std::underlying_type_t<ODriveIntf::MotorIntf::Error>&>(a) &= static_cast<std::underlying_type_t<ODriveIntf::MotorIntf::Error>>(b)); }
inline ODriveIntf::MotorIntf::Error& operator ^= (ODriveIntf::MotorIntf::Error &a, ODriveIntf::MotorIntf::Error b) { return reinterpret_cast<ODriveIntf::MotorIntf::Error&>(reinterpret_cast<std::underlying_type_t<ODriveIntf::MotorIntf::Error>&>(a) ^= static_cast<std::underlying_type_t<ODriveIntf::MotorIntf::Error>>(b)); }
inline ODriveIntf::MotorIntf::Error operator ~ (ODriveIntf::MotorIntf::Error a) { return static_cast<ODriveIntf::MotorIntf::Error>(~static_cast<std::underlying_type_t<ODriveIntf::MotorIntf::Error>>(a)); }
// this is technically not thread-safe but practically it might be
inline ODriveIntf::MotorIntf::GateDriverIntf::DrvFault operator | (ODriveIntf::MotorIntf::GateDriverIntf::DrvFault a, ODriveIntf::MotorIntf::GateDriverIntf::DrvFault b) { return static_cast<ODriveIntf::MotorIntf::GateDriverIntf::DrvFault>(static_cast<std::underlying_type_t<ODriveIntf::MotorIntf::GateDriverIntf::DrvFault>>(a) | static_cast<std::underlying_type_t<ODriveIntf::MotorIntf::GateDriverIntf::DrvFault>>(b)); }
inline ODriveIntf::MotorIntf::GateDriverIntf::DrvFault operator & (ODriveIntf::MotorIntf::GateDriverIntf::DrvFault a, ODriveIntf::MotorIntf::GateDriverIntf::DrvFault b) { return static_cast<ODriveIntf::MotorIntf::GateDriverIntf::DrvFault>(static_cast<std::underlying_type_t<ODriveIntf::MotorIntf::GateDriverIntf::DrvFault>>(a) & static_cast<std::underlying_type_t<ODriveIntf::MotorIntf::GateDriverIntf::DrvFault>>(b)); }
inline ODriveIntf::MotorIntf::GateDriverIntf::DrvFault operator ^ (ODriveIntf::MotorIntf::GateDriverIntf::DrvFault a, ODriveIntf::MotorIntf::GateDriverIntf::DrvFault b) { return static_cast<ODriveIntf::MotorIntf::GateDriverIntf::DrvFault>(static_cast<std::underlying_type_t<ODriveIntf::MotorIntf::GateDriverIntf::DrvFault>>(a) ^ static_cast<std::underlying_type_t<ODriveIntf::MotorIntf::GateDriverIntf::DrvFault>>(b)); }
inline ODriveIntf::MotorIntf::GateDriverIntf::DrvFault& operator |= (ODriveIntf::MotorIntf::GateDriverIntf::DrvFault &a, ODriveIntf::MotorIntf::GateDriverIntf::DrvFault b) { return reinterpret_cast<ODriveIntf::MotorIntf::GateDriverIntf::DrvFault&>(reinterpret_cast<std::underlying_type_t<ODriveIntf::MotorIntf::GateDriverIntf::DrvFault>&>(a) |= static_cast<std::underlying_type_t<ODriveIntf::MotorIntf::GateDriverIntf::DrvFault>>(b)); }
inline ODriveIntf::MotorIntf::GateDriverIntf::DrvFault& operator &= (ODriveIntf::MotorIntf::GateDriverIntf::DrvFault &a, ODriveIntf::MotorIntf::GateDriverIntf::DrvFault b) { return reinterpret_cast<ODriveIntf::MotorIntf::GateDriverIntf::DrvFault&>(reinterpret_cast<std::underlying_type_t<ODriveIntf::MotorIntf::GateDriverIntf::DrvFault>&>(a) &= static_cast<std::underlying_type_t<ODriveIntf::MotorIntf::GateDriverIntf::DrvFault>>(b)); }
inline ODriveIntf::MotorIntf::GateDriverIntf::DrvFault& operator ^= (ODriveIntf::MotorIntf::GateDriverIntf::DrvFault &a, ODriveIntf::MotorIntf::GateDriverIntf::DrvFault b) { return reinterpret_cast<ODriveIntf::MotorIntf::GateDriverIntf::DrvFault&>(reinterpret_cast<std::underlying_type_t<ODriveIntf::MotorIntf::GateDriverIntf::DrvFault>&>(a) ^= static_cast<std::underlying_type_t<ODriveIntf::MotorIntf::GateDriverIntf::DrvFault>>(b)); }
inline ODriveIntf::MotorIntf::GateDriverIntf::DrvFault operator ~ (ODriveIntf::MotorIntf::GateDriverIntf::DrvFault a) { return static_cast<ODriveIntf::MotorIntf::GateDriverIntf::DrvFault>(~static_cast<std::underlying_type_t<ODriveIntf::MotorIntf::GateDriverIntf::DrvFault>>(a)); }
// this is technically not thread-safe but practically it might be
inline ODriveIntf::ControllerIntf::Error operator | (ODriveIntf::ControllerIntf::Error a, ODriveIntf::ControllerIntf::Error b) { return static_cast<ODriveIntf::ControllerIntf::Error>(static_cast<std::underlying_type_t<ODriveIntf::ControllerIntf::Error>>(a) | static_cast<std::underlying_type_t<ODriveIntf::ControllerIntf::Error>>(b)); }
inline ODriveIntf::ControllerIntf::Error operator & (ODriveIntf::ControllerIntf::Error a, ODriveIntf::ControllerIntf::Error b) { return static_cast<ODriveIntf::ControllerIntf::Error>(static_cast<std::underlying_type_t<ODriveIntf::ControllerIntf::Error>>(a) & static_cast<std::underlying_type_t<ODriveIntf::ControllerIntf::Error>>(b)); }
inline ODriveIntf::ControllerIntf::Error operator ^ (ODriveIntf::ControllerIntf::Error a, ODriveIntf::ControllerIntf::Error b) { return static_cast<ODriveIntf::ControllerIntf::Error>(static_cast<std::underlying_type_t<ODriveIntf::ControllerIntf::Error>>(a) ^ static_cast<std::underlying_type_t<ODriveIntf::ControllerIntf::Error>>(b)); }
inline ODriveIntf::ControllerIntf::Error& operator |= (ODriveIntf::ControllerIntf::Error &a, ODriveIntf::ControllerIntf::Error b) { return reinterpret_cast<ODriveIntf::ControllerIntf::Error&>(reinterpret_cast<std::underlying_type_t<ODriveIntf::ControllerIntf::Error>&>(a) |= static_cast<std::underlying_type_t<ODriveIntf::ControllerIntf::Error>>(b)); }
inline ODriveIntf::ControllerIntf::Error& operator &= (ODriveIntf::ControllerIntf::Error &a, ODriveIntf::ControllerIntf::Error b) { return reinterpret_cast<ODriveIntf::ControllerIntf::Error&>(reinterpret_cast<std::underlying_type_t<ODriveIntf::ControllerIntf::Error>&>(a) &= static_cast<std::underlying_type_t<ODriveIntf::ControllerIntf::Error>>(b)); }
inline ODriveIntf::ControllerIntf::Error& operator ^= (ODriveIntf::ControllerIntf::Error &a, ODriveIntf::ControllerIntf::Error b) { return reinterpret_cast<ODriveIntf::ControllerIntf::Error&>(reinterpret_cast<std::underlying_type_t<ODriveIntf::ControllerIntf::Error>&>(a) ^= static_cast<std::underlying_type_t<ODriveIntf::ControllerIntf::Error>>(b)); }
inline ODriveIntf::ControllerIntf::Error operator ~ (ODriveIntf::ControllerIntf::Error a) { return static_cast<ODriveIntf::ControllerIntf::Error>(~static_cast<std::underlying_type_t<ODriveIntf::ControllerIntf::Error>>(a)); }
// this is technically not thread-safe but practically it might be
inline ODriveIntf::EncoderIntf::Error operator | (ODriveIntf::EncoderIntf::Error a, ODriveIntf::EncoderIntf::Error b) { return static_cast<ODriveIntf::EncoderIntf::Error>(static_cast<std::underlying_type_t<ODriveIntf::EncoderIntf::Error>>(a) | static_cast<std::underlying_type_t<ODriveIntf::EncoderIntf::Error>>(b)); }
inline ODriveIntf::EncoderIntf::Error operator & (ODriveIntf::EncoderIntf::Error a, ODriveIntf::EncoderIntf::Error b) { return static_cast<ODriveIntf::EncoderIntf::Error>(static_cast<std::underlying_type_t<ODriveIntf::EncoderIntf::Error>>(a) & static_cast<std::underlying_type_t<ODriveIntf::EncoderIntf::Error>>(b)); }
inline ODriveIntf::EncoderIntf::Error operator ^ (ODriveIntf::EncoderIntf::Error a, ODriveIntf::EncoderIntf::Error b) { return static_cast<ODriveIntf::EncoderIntf::Error>(static_cast<std::underlying_type_t<ODriveIntf::EncoderIntf::Error>>(a) ^ static_cast<std::underlying_type_t<ODriveIntf::EncoderIntf::Error>>(b)); }
inline ODriveIntf::EncoderIntf::Error& operator |= (ODriveIntf::EncoderIntf::Error &a, ODriveIntf::EncoderIntf::Error b) { return reinterpret_cast<ODriveIntf::EncoderIntf::Error&>(reinterpret_cast<std::underlying_type_t<ODriveIntf::EncoderIntf::Error>&>(a) |= static_cast<std::underlying_type_t<ODriveIntf::EncoderIntf::Error>>(b)); }
inline ODriveIntf::EncoderIntf::Error& operator &= (ODriveIntf::EncoderIntf::Error &a, ODriveIntf::EncoderIntf::Error b) { return reinterpret_cast<ODriveIntf::EncoderIntf::Error&>(reinterpret_cast<std::underlying_type_t<ODriveIntf::EncoderIntf::Error>&>(a) &= static_cast<std::underlying_type_t<ODriveIntf::EncoderIntf::Error>>(b)); }
inline ODriveIntf::EncoderIntf::Error& operator ^= (ODriveIntf::EncoderIntf::Error &a, ODriveIntf::EncoderIntf::Error b) { return reinterpret_cast<ODriveIntf::EncoderIntf::Error&>(reinterpret_cast<std::underlying_type_t<ODriveIntf::EncoderIntf::Error>&>(a) ^= static_cast<std::underlying_type_t<ODriveIntf::EncoderIntf::Error>>(b)); }
inline ODriveIntf::EncoderIntf::Error operator ~ (ODriveIntf::EncoderIntf::Error a) { return static_cast<ODriveIntf::EncoderIntf::Error>(~static_cast<std::underlying_type_t<ODriveIntf::EncoderIntf::Error>>(a)); }
// this is technically not thread-safe but practically it might be
inline ODriveIntf::SensorlessEstimatorIntf::Error operator | (ODriveIntf::SensorlessEstimatorIntf::Error a, ODriveIntf::SensorlessEstimatorIntf::Error b) { return static_cast<ODriveIntf::SensorlessEstimatorIntf::Error>(static_cast<std::underlying_type_t<ODriveIntf::SensorlessEstimatorIntf::Error>>(a) | static_cast<std::underlying_type_t<ODriveIntf::SensorlessEstimatorIntf::Error>>(b)); }
inline ODriveIntf::SensorlessEstimatorIntf::Error operator & (ODriveIntf::SensorlessEstimatorIntf::Error a, ODriveIntf::SensorlessEstimatorIntf::Error b) { return static_cast<ODriveIntf::SensorlessEstimatorIntf::Error>(static_cast<std::underlying_type_t<ODriveIntf::SensorlessEstimatorIntf::Error>>(a) & static_cast<std::underlying_type_t<ODriveIntf::SensorlessEstimatorIntf::Error>>(b)); }
inline ODriveIntf::SensorlessEstimatorIntf::Error operator ^ (ODriveIntf::SensorlessEstimatorIntf::Error a, ODriveIntf::SensorlessEstimatorIntf::Error b) { return static_cast<ODriveIntf::SensorlessEstimatorIntf::Error>(static_cast<std::underlying_type_t<ODriveIntf::SensorlessEstimatorIntf::Error>>(a) ^ static_cast<std::underlying_type_t<ODriveIntf::SensorlessEstimatorIntf::Error>>(b)); }
inline ODriveIntf::SensorlessEstimatorIntf::Error& operator |= (ODriveIntf::SensorlessEstimatorIntf::Error &a, ODriveIntf::SensorlessEstimatorIntf::Error b) { return reinterpret_cast<ODriveIntf::SensorlessEstimatorIntf::Error&>(reinterpret_cast<std::underlying_type_t<ODriveIntf::SensorlessEstimatorIntf::Error>&>(a) |= static_cast<std::underlying_type_t<ODriveIntf::SensorlessEstimatorIntf::Error>>(b)); }
inline ODriveIntf::SensorlessEstimatorIntf::Error& operator &= (ODriveIntf::SensorlessEstimatorIntf::Error &a, ODriveIntf::SensorlessEstimatorIntf::Error b) { return reinterpret_cast<ODriveIntf::SensorlessEstimatorIntf::Error&>(reinterpret_cast<std::underlying_type_t<ODriveIntf::SensorlessEstimatorIntf::Error>&>(a) &= static_cast<std::underlying_type_t<ODriveIntf::SensorlessEstimatorIntf::Error>>(b)); }
inline ODriveIntf::SensorlessEstimatorIntf::Error& operator ^= (ODriveIntf::SensorlessEstimatorIntf::Error &a, ODriveIntf::SensorlessEstimatorIntf::Error b) { return reinterpret_cast<ODriveIntf::SensorlessEstimatorIntf::Error&>(reinterpret_cast<std::underlying_type_t<ODriveIntf::SensorlessEstimatorIntf::Error>&>(a) ^= static_cast<std::underlying_type_t<ODriveIntf::SensorlessEstimatorIntf::Error>>(b)); }
inline ODriveIntf::SensorlessEstimatorIntf::Error operator ~ (ODriveIntf::SensorlessEstimatorIntf::Error a) { return static_cast<ODriveIntf::SensorlessEstimatorIntf::Error>(~static_cast<std::underlying_type_t<ODriveIntf::SensorlessEstimatorIntf::Error>>(a)); }



#pragma GCC pop_options